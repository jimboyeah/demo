<!DOCTYPE html><html><head><meta charset="utf-8"><style>body {
  width: 45em;
  border: 1px solid #ddd;
  outline: 1300px solid #fff;
  margin: 16px auto;
}

body .markdown-body
{
  padding: 30px;
}

@font-face {
  font-family: fontawesome-mini;
  src: url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAAAzUABAAAAAAFNgAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAABbAAAABwAAAAcZMzaOEdERUYAAAGIAAAAHQAAACAAOQAET1MvMgAAAagAAAA+AAAAYHqhde9jbWFwAAAB6AAAAFIAAAFa4azkLWN2dCAAAAI8AAAAKAAAACgFgwioZnBnbQAAAmQAAAGxAAACZVO0L6dnYXNwAAAEGAAAAAgAAAAIAAAAEGdseWYAAAQgAAAFDgAACMz7eroHaGVhZAAACTAAAAAwAAAANgWEOEloaGVhAAAJYAAAAB0AAAAkDGEGa2htdHgAAAmAAAAAEwAAADBEgAAQbG9jYQAACZQAAAAaAAAAGgsICJBtYXhwAAAJsAAAACAAAAAgASgBD25hbWUAAAnQAAACZwAABOD4no+3cG9zdAAADDgAAABsAAAAmF+yXM9wcmVwAAAMpAAAAC4AAAAusPIrFAAAAAEAAAAAyYlvMQAAAADLVHQgAAAAAM/u9uZ4nGNgZGBg4ANiCQYQYGJgBEJuIGYB8xgABMMAPgAAAHicY2Bm42OcwMDKwMLSw2LMwMDQBqGZihmiwHycoKCyqJjB4YPDh4NsDP+BfNb3DIuAFCOSEgUGRgAKDgt4AAB4nGNgYGBmgGAZBkYGEAgB8hjBfBYGCyDNxcDBwMTA9MHhQ9SHrA8H//9nYACyQyFs/sP86/kX8HtB9UIBIxsDXICRCUgwMaACRoZhDwA3fxKSAAAAAAHyAHABJQB/AIEAdAFGAOsBIwC/ALgAxACGAGYAugBNACcA/wCIeJxdUbtOW0EQ3Q0PA4HE2CA52hSzmZDGe6EFCcTVjWJkO4XlCGk3cpGLcQEfQIFEDdqvGaChpEibBiEXSHxCPiESM2uIojQ7O7NzzpkzS8qRqnfpa89T5ySQwt0GzTb9Tki1swD3pOvrjYy0gwdabGb0ynX7/gsGm9GUO2oA5T1vKQ8ZTTuBWrSn/tH8Cob7/B/zOxi0NNP01DoJ6SEE5ptxS4PvGc26yw/6gtXhYjAwpJim4i4/plL+tzTnasuwtZHRvIMzEfnJNEBTa20Emv7UIdXzcRRLkMumsTaYmLL+JBPBhcl0VVO1zPjawV2ys+hggyrNgQfYw1Z5DB4ODyYU0rckyiwNEfZiq8QIEZMcCjnl3Mn+pED5SBLGvElKO+OGtQbGkdfAoDZPs/88m01tbx3C+FkcwXe/GUs6+MiG2hgRYjtiKYAJREJGVfmGGs+9LAbkUvvPQJSA5fGPf50ItO7YRDyXtXUOMVYIen7b3PLLirtWuc6LQndvqmqo0inN+17OvscDnh4Lw0FjwZvP+/5Kgfo8LK40aA4EQ3o3ev+iteqIq7wXPrIn07+xWgAAAAABAAH//wAPeJyFlctvG1UUh+/12DPN1B7P3JnYjj2Ox4/MuDHxJH5N3UdaEUQLqBIkfQQioJWQ6AMEQkIqsPGCPwA1otuWSmTBhjtps2ADWbJg3EpIXbGouqSbCraJw7kzNo2dRN1cnXN1ZvT7zuuiMEI7ncizyA0URofRBJpCdbQuIFShYY+GZRrxMDVtih5TwQPHtXDFFSIKoWIbuREBjLH27Ny4MsbVx+uOJThavebgVrNRLAiYx06rXsvhxLgWx9xpfHdrs/ekc2Pl2cpPCVEITQpwbj8VQhfXSq2m+Wxqaq2D73Kne5e3NjHqQNj3CRYlJlgUl/jRNP+2Gs2pNYRQiOnmUaQDqm30KqKiTTWPWjboxnTWpvgxjXo0KrtZXAHt7hwIz0YVcj88JnKlJKi3NPAwLyDwZudSmJSMMJFDYaOkaol6XtESx3Gt1VTytdZJ3DCLeaVhVnCBH1fycHTxFXwPX+l2e3d6H/TufGGmMTLTnbSJUdo00zuBswMO/nl3YLeL/wnu9/limCuD3vC54h5NBVz6Li414AI8Vx3iiosKcQXUbrvhFFiYb++HN4DaF4XzFW0fIN4XDWJ3a3XQoq9V8WiyRmdsatV9xUcHims1JloH0YUa090G3Tro3mC6c01f+YwCPquINr1PTaCP6rVTOOmf0GE2dBc7zWIhji3/5MchSuBHgDbU99RMWt3YUNMZMJmx92YP6NsHx/5/M1yvInpnkIOM3Z8fA3JQ2lW1RFC1KaBPDFXNAHYYvGy73aYZZZ3HifbeuiVZCpwA3oQBs0wGPYJbJfg60xrKEbKiNtTe1adwrpBRwlAuQ3q3VRaX0QmQ9a49BTSCuF1MLfQ6+tinOubRBZuWPNoMevGMT+V41KitO1is3D/tpMcq1JHZqDHGs8DoYGDkxJgKjHROeTCmhZvzPm9pod+ltKm4PN7Dyvvldlpsg8D+4AUJZ3F/JBstZz7cbFRxsaAGV6yX/dkcycWf8eS3QlQea+YLjdm3yrOnrhFpUyKVvFE4lpv4bO3Svx/6F/4xmiDu/RT5iI++lko18mY1oX+5UGKR6kmVjM/Zb76yfHtxy+h/SyQ0lLdpdKy/lWB6szatetQJ8nZ80A2Qt6ift6gJeavU3BO4gtxs/KCtNPVibCtYCWY3SIlSBPKXZALXiIR9oZeJ1AuMyxLpHIy/yO7vSiSE+kZvk0ihJ30HgHfzZtEMmvV58x6dtqns0XTAW7Vdm4HJ04OCp/crOO7rd9SGxQAE/mVA9xRN+kVSMRFF6S9JFGUtthkjBA5tFCWc2l4V43Ex9GmUP3SI37Jjmir9KqlaDJ4S4JB3vuM/jzyH1+8MuoZ+QGzfnvPoJb96cZlWjMcKLfgDwB7E634JTY+asjsPzS5CiVnEWY+KsrsIN5rn3mAPjqmQBxGjcGKB9f9ZxY3mYC2L85CJ2FXIxKKyHk+dg0FHbuEc7D5NzWUX32WxFcWNGRAbvwSx0RmIXVDuYySafluQBmzA/ssqJAMLnli+WIC90Gw4lm85wcp0qjArEDPJJV/sSx4P9ungTpgMw5gVC1XO4uULq0s3v1rqLi0vX/z65vlH50f8T/RHmSPTk5xxWBWOluMT6WiOy+tdvWxlV/XQb3o3c6Ssr+r6I708GsX9/nzp1tKFh0s3v7m4vAy/Hnb/KMOvc1wump6Il48K6mGDy02X9Yd65pa+nQIjk76lWxCkG8NBCP0HQS9IpAAAeJxjYGRgYGBhcCrq214Qz2/zlUGenQEEzr/77oug/zewFbB+AHI5GJhAogBwKQ0qeJxjYGRgYH3/P46BgZ0BBNgKGBgZUAEPAE/7At0AAAB4nGNngAB2IGYjhBsYBAAIYADVAAAAAAAAAAAAAFwAyAEeAaACCgKmAx4DggRmAAAAAQAAAAwAagAEAAAAAAACAAEAAgAWAAABAAChAAAAAHiclZI7bxQxFIWPd/JkUYQChEhIyAVKgdBMskm1QkKrRETpQiLRUczueB/K7HhlOxttg8LvoKPgP9DxFxANDR0tHRWi4NjrPIBEgh1p/dm+vufcawNYFWsQmP6e4jSyQB2fI9cwj++RE9wTjyPP4LYoI89iWbyLPIe6+Bh5Hs9rryMv4GbtW+RF3EhuRa7jbrIbeQkPkjdUETOLnL0Kip4FVvAhco1RXyMnSPEz8gzWxE7kWTwUp5HnsCLeR57HW/El8gJWa58iL+JO7UfkOh4l9yMv4UnyEtvQGGECgwF66MNBooF1bGCL1ELB/TYU+ZBRlvsKQ44Se6jQ4a7hef+fh72Crv25kp+8lNWGmeKoOI5jJLb1aGIGvb6TjfWNLdkqdFvJw4l1amjlXtXRZqRN7lSRylZZyhBqpVFWmTEXgWfUrpi/hZOQXdOd4rKuXOtEWT3k5IArPRzTUU5tHKjecZkTpnVbNOnt6jzN8240GD4xtikvZW56043rPMg/dS+dlOceXoR+WPbJ55Dsekq1lJpnypsMUsYOdCW30o103Ytu/lvh+5RWFLfBjm9/N8hJntPhvx92rnoE/kyHdGasGy754kw36vsVf/lFeBi+0COu+cfgQr42G3CRpeLoZ53gmfe3X6rcKt5oVxnptHR9JS8ehVUd5wvvahN2uqxOOpMXapibI5k7Zwbt4xBSaTfoKBufhAnO/uqNcfK8OTs0OQ6l7JIqFjDhYj5WcjevCnI/1DDiI8j4ndWb/5YzDZWh79yomWXeXj7Nnw70/2TIeFPTrlSh89k1ObOSRVZWZfgF0r/zJQB4nG2JUQuCQBCEd07TTg36fb2IyBaLd3vWaUh/vmSJnvpgmG8YcmS8X3Shf3R7QA4OBUocUKHGER5NNbOOEvwc1txnuWkTRb/aPjimJ5vXabI+3VfOiyS15UWvyezM2xiGOPyuMohOH8O8JiO4Af+FsAGNAEuwCFBYsQEBjlmxRgYrWCGwEFlLsBRSWCGwgFkdsAYrXFhZsBQrAAA=) format('woff');
}

@font-face {
  font-family: octicons-anchor;
  src: url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAAAYcAA0AAAAACjQAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAABMAAAABwAAAAca8vGTk9TLzIAAAFMAAAARAAAAFZG1VHVY21hcAAAAZAAAAA+AAABQgAP9AdjdnQgAAAB0AAAAAQAAAAEACICiGdhc3AAAAHUAAAACAAAAAj//wADZ2x5ZgAAAdwAAADRAAABEKyikaNoZWFkAAACsAAAAC0AAAA2AtXoA2hoZWEAAALgAAAAHAAAACQHngNFaG10eAAAAvwAAAAQAAAAEAwAACJsb2NhAAADDAAAAAoAAAAKALIAVG1heHAAAAMYAAAAHwAAACABEAB2bmFtZQAAAzgAAALBAAAFu3I9x/Nwb3N0AAAF/AAAAB0AAAAvaoFvbwAAAAEAAAAAzBdyYwAAAADP2IQvAAAAAM/bz7t4nGNgZGFgnMDAysDB1Ml0hoGBoR9CM75mMGLkYGBgYmBlZsAKAtJcUxgcPsR8iGF2+O/AEMPsznAYKMwIkgMA5REMOXicY2BgYGaAYBkGRgYQsAHyGMF8FgYFIM0ChED+h5j//yEk/3KoSgZGNgYYk4GRCUgwMaACRoZhDwCs7QgGAAAAIgKIAAAAAf//AAJ4nHWMMQrCQBBF/0zWrCCIKUQsTDCL2EXMohYGSSmorScInsRGL2DOYJe0Ntp7BK+gJ1BxF1stZvjz/v8DRghQzEc4kIgKwiAppcA9LtzKLSkdNhKFY3HF4lK69ExKslx7Xa+vPRVS43G98vG1DnkDMIBUgFN0MDXflU8tbaZOUkXUH0+U27RoRpOIyCKjbMCVejwypzJJG4jIwb43rfl6wbwanocrJm9XFYfskuVC5K/TPyczNU7b84CXcbxks1Un6H6tLH9vf2LRnn8Ax7A5WQAAAHicY2BkYGAA4teL1+yI57f5ysDNwgAC529f0kOmWRiYVgEpDgYmEA8AUzEKsQAAAHicY2BkYGB2+O/AEMPCAAJAkpEBFbAAADgKAe0EAAAiAAAAAAQAAAAEAAAAAAAAKgAqACoAiAAAeJxjYGRgYGBhsGFgYgABEMkFhAwM/xn0QAIAD6YBhwB4nI1Ty07cMBS9QwKlQapQW3VXySvEqDCZGbGaHULiIQ1FKgjWMxknMfLEke2A+IJu+wntrt/QbVf9gG75jK577Lg8K1qQPCfnnnt8fX1NRC/pmjrk/zprC+8D7tBy9DHgBXoWfQ44Av8t4Bj4Z8CLtBL9CniJluPXASf0Lm4CXqFX8Q84dOLnMB17N4c7tBo1AS/Qi+hTwBH4rwHHwN8DXqQ30XXAS7QaLwSc0Gn8NuAVWou/gFmnjLrEaEh9GmDdDGgL3B4JsrRPDU2hTOiMSuJUIdKQQayiAth69r6akSSFqIJuA19TrzCIaY8sIoxyrNIrL//pw7A2iMygkX5vDj+G+kuoLdX4GlGK/8Lnlz6/h9MpmoO9rafrz7ILXEHHaAx95s9lsI7AHNMBWEZHULnfAXwG9/ZqdzLI08iuwRloXE8kfhXYAvE23+23DU3t626rbs8/8adv+9DWknsHp3E17oCf+Z48rvEQNZ78paYM38qfk3v/u3l3u3GXN2Dmvmvpf1Srwk3pB/VSsp512bA/GG5i2WJ7wu430yQ5K3nFGiOqgtmSB5pJVSizwaacmUZzZhXLlZTq8qGGFY2YcSkqbth6aW1tRmlaCFs2016m5qn36SbJrqosG4uMV4aP2PHBmB3tjtmgN2izkGQyLWprekbIntJFing32a5rKWCN/SdSoga45EJykyQ7asZvHQ8PTm6cslIpwyeyjbVltNikc2HTR7YKh9LBl9DADC0U/jLcBZDKrMhUBfQBvXRzLtFtjU9eNHKin0x5InTqb8lNpfKv1s1xHzTXRqgKzek/mb7nB8RZTCDhGEX3kK/8Q75AmUM/eLkfA+0Hi908Kx4eNsMgudg5GLdRD7a84npi+YxNr5i5KIbW5izXas7cHXIMAau1OueZhfj+cOcP3P8MNIWLyYOBuxL6DRylJ4cAAAB4nGNgYoAALjDJyIAOWMCiTIxMLDmZedkABtIBygAAAA==) format('woff');
}

.markdown-body {
  font-family: sans-serif;
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  color: #333333;
  overflow: hidden;
  font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif;
  font-size: 16px;
  line-height: 1.6;
  word-wrap: break-word;
}

.markdown-body a {
  background: transparent;
}

.markdown-body a:active,
.markdown-body a:hover {
  outline: 0;
}

.markdown-body b,
.markdown-body strong {
  font-weight: bold;
}

.markdown-body mark {
  background: #ff0;
  color: #000;
  font-style: italic;
  font-weight: bold;
}

.markdown-body sub,
.markdown-body sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}
.markdown-body sup {
  top: -0.5em;
}
.markdown-body sub {
  bottom: -0.25em;
}

.markdown-body h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

.markdown-body img {
  border: 0;
}

.markdown-body hr {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  height: 0;
}

.markdown-body pre {
  overflow: auto;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre,
.markdown-body samp {
  font-family: monospace, monospace;
  font-size: 1em;
}

.markdown-body input {
  color: inherit;
  font: inherit;
  margin: 0;
}

.markdown-body html input[disabled] {
  cursor: default;
}

.markdown-body input {
  line-height: normal;
}

.markdown-body input[type="checkbox"] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body table {
  border-collapse: collapse;
  border-spacing: 0;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body .codehilitetable {
  border: 0;
  border-spacing: 0;
}

.markdown-body .codehilitetable tr {
  border: 0;
}

.markdown-body .codehilitetable pre,
.markdown-body .codehilitetable div.codehilite {
  margin: 0;
}

.markdown-body .linenos,
.markdown-body .code,
.markdown-body .codehilitetable td {
  border: 0;
  padding: 0;
}

.markdown-body td:not(.linenos) .linenodiv {
  padding: 0 !important;
}

.markdown-body .code {
  width: 100%;
}

.markdown-body .linenos div pre,
.markdown-body .linenodiv pre,
.markdown-body .linenodiv {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-left-radius: 3px;
  -webkit-border-bottom-left-radius: 3px;
  -moz-border-radius-topleft: 3px;
  -moz-border-radius-bottomleft: 3px;
  border-top-left-radius: 3px;
  border-bottom-left-radius: 3px;
}

.markdown-body .code div pre,
.markdown-body .code div {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-right-radius: 3px;
  -webkit-border-bottom-right-radius: 3px;
  -moz-border-radius-topright: 3px;
  -moz-border-radius-bottomright: 3px;
  border-top-right-radius: 3px;
  border-bottom-right-radius: 3px;
}

.markdown-body * {
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body input {
  font: 13px Helvetica, arial, freesans, clean, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol";
  line-height: 1.4;
}

.markdown-body a {
  color: #4183c4;
  text-decoration: none;
}

.markdown-body a:hover,
.markdown-body a:focus,
.markdown-body a:active {
  text-decoration: underline;
}

.markdown-body hr {
  height: 0;
  margin: 15px 0;
  overflow: hidden;
  background: transparent;
  border: 0;
  border-bottom: 1px solid #ddd;
}

.markdown-body hr:before,
.markdown-body hr:after {
  display: table;
  content: " ";
}

.markdown-body hr:after {
  clear: both;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 15px;
  margin-bottom: 15px;
  line-height: 1.1;
}

.markdown-body h1 {
  font-size: 30px;
}

.markdown-body h2 {
  font-size: 21px;
}

.markdown-body h3 {
  font-size: 16px;
}

.markdown-body h4 {
  font-size: 14px;
}

.markdown-body h5 {
  font-size: 12px;
}

.markdown-body h6 {
  font-size: 11px;
}

.markdown-body blockquote {
  margin: 0;
}

.markdown-body ul,
.markdown-body ol {
  padding: 0;
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ul ul ol,
.markdown-body ul ol ol,
.markdown-body ol ul ol,
.markdown-body ol ol ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body code,
.markdown-body pre,
.markdown-body samp {
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body kbd {
  background-color: #e7e7e7;
  background-image: -moz-linear-gradient(#fefefe, #e7e7e7);
  background-image: -webkit-linear-gradient(#fefefe, #e7e7e7);
  background-image: linear-gradient(#fefefe, #e7e7e7);
  background-repeat: repeat-x;
  border-radius: 2px;
  border: 1px solid #cfcfcf;
  color: #000;
  padding: 3px 5px;
  line-height: 10px;
  font: 11px Consolas, "Liberation Mono", Menlo, Courier, monospace;
  display: inline-block;
}

.markdown-body>*:first-child {
  margin-top: 0 !important;
}

.markdown-body>*:last-child {
  margin-bottom: 0 !important;
}

.markdown-body .headeranchor-link {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  display: block;
  padding-right: 6px;
  padding-left: 30px;
  margin-left: -30px;
}

.markdown-body .headeranchor-link:focus {
  outline: none;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  position: relative;
  margin-top: 1em;
  margin-bottom: 16px;
  font-weight: bold;
  line-height: 1.4;
}

.markdown-body h1 .headeranchor,
.markdown-body h2 .headeranchor,
.markdown-body h3 .headeranchor,
.markdown-body h4 .headeranchor,
.markdown-body h5 .headeranchor,
.markdown-body h6 .headeranchor {
  display: none;
  color: #000;
  vertical-align: middle;
}

.markdown-body h1:hover .headeranchor-link,
.markdown-body h2:hover .headeranchor-link,
.markdown-body h3:hover .headeranchor-link,
.markdown-body h4:hover .headeranchor-link,
.markdown-body h5:hover .headeranchor-link,
.markdown-body h6:hover .headeranchor-link {
  height: 1em;
  padding-left: 8px;
  margin-left: -30px;
  line-height: 1;
  text-decoration: none;
}

.markdown-body h1:hover .headeranchor-link .headeranchor,
.markdown-body h2:hover .headeranchor-link .headeranchor,
.markdown-body h3:hover .headeranchor-link .headeranchor,
.markdown-body h4:hover .headeranchor-link .headeranchor,
.markdown-body h5:hover .headeranchor-link .headeranchor,
.markdown-body h6:hover .headeranchor-link .headeranchor {
  display: inline-block;
}

.markdown-body h1 {
  padding-bottom: 0.3em;
  font-size: 2.25em;
  line-height: 1.2;
  border-bottom: 1px solid #eee;
}

.markdown-body h2 {
  padding-bottom: 0.3em;
  font-size: 1.75em;
  line-height: 1.225;
  border-bottom: 1px solid #eee;
}

.markdown-body h3 {
  font-size: 1.5em;
  line-height: 1.43;
}

.markdown-body h4 {
  font-size: 1.25em;
}

.markdown-body h5 {
  font-size: 1em;
}

.markdown-body h6 {
  font-size: 1em;
  color: #777;
}

.markdown-body p,
.markdown-body blockquote,
.markdown-body ul,
.markdown-body ol,
.markdown-body dl,
.markdown-body table,
.markdown-body pre,
.markdown-body .admonition {
  margin-top: 0;
  margin-bottom: 16px;
}

.markdown-body hr {
  height: 4px;
  padding: 0;
  margin: 16px 0;
  background-color: #e7e7e7;
  border: 0 none;
}

.markdown-body ul,
.markdown-body ol {
  padding-left: 2em;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: bold;
}

.markdown-body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

.markdown-body blockquote {
  padding: 0 15px;
  color: #777;
  border-left: 4px solid #ddd;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body table {
  display: block;
  width: 100%;
  overflow: auto;
  word-break: normal;
  word-break: keep-all;
}

.markdown-body table th {
  font-weight: bold;
}

.markdown-body table th,
.markdown-body table td {
  padding: 6px 13px;
  border: 1px solid #ddd;
}

.markdown-body table tr {
  background-color: #fff;
  border-top: 1px solid #ccc;
}

.markdown-body table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

.markdown-body img {
  max-width: 100%;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body code,
.markdown-body samp {
  padding: 0;
  padding-top: 0.2em;
  padding-bottom: 0.2em;
  margin: 0;
  font-size: 85%;
  background-color: rgba(0,0,0,0.04);
  border-radius: 3px;
}

.markdown-body code:before,
.markdown-body code:after {
  letter-spacing: -0.2em;
  content: "\00a0";
}

.markdown-body pre>code {
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.markdown-body .codehilite {
  margin-bottom: 16px;
}

.markdown-body .codehilite pre,
.markdown-body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: #f7f7f7;
  border-radius: 3px;
}

.markdown-body .codehilite pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body pre {
  word-wrap: normal;
}

.markdown-body pre code {
  display: inline;
  max-width: initial;
  padding: 0;
  margin: 0;
  overflow: initial;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

.markdown-body pre code:before,
.markdown-body pre code:after {
  content: normal;
}

/* Admonition */
.markdown-body .admonition {
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  position: relative;
  border-radius: 3px;
  border: 1px solid #e0e0e0;
  border-left: 6px solid #333;
  padding: 10px 10px 10px 30px;
}

.markdown-body .admonition table {
  color: #333;
}

.markdown-body .admonition p {
  padding: 0;
}

.markdown-body .admonition-title {
  font-weight: bold;
  margin: 0;
}

.markdown-body .admonition>.admonition-title {
  color: #333;
}

.markdown-body .attention>.admonition-title {
  color: #a6d796;
}

.markdown-body .caution>.admonition-title {
  color: #d7a796;
}

.markdown-body .hint>.admonition-title {
  color: #96c6d7;
}

.markdown-body .danger>.admonition-title {
  color: #c25f77;
}

.markdown-body .question>.admonition-title {
  color: #96a6d7;
}

.markdown-body .note>.admonition-title {
  color: #d7c896;
}

.markdown-body .admonition:before,
.markdown-body .attention:before,
.markdown-body .caution:before,
.markdown-body .hint:before,
.markdown-body .danger:before,
.markdown-body .question:before,
.markdown-body .note:before {
  font: normal normal 16px fontawesome-mini;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  line-height: 1.5;
  color: #333;
  position: absolute;
  left: 0;
  top: 0;
  padding-top: 10px;
  padding-left: 10px;
}

.markdown-body .admonition:before {
  content: "\f056\00a0";
  color: 333;
}

.markdown-body .attention:before {
  content: "\f058\00a0";
  color: #a6d796;
}

.markdown-body .caution:before {
  content: "\f06a\00a0";
  color: #d7a796;
}

.markdown-body .hint:before {
  content: "\f05a\00a0";
  color: #96c6d7;
}

.markdown-body .danger:before {
  content: "\f057\00a0";
  color: #c25f77;
}

.markdown-body .question:before {
  content: "\f059\00a0";
  color: #96a6d7;
}

.markdown-body .note:before {
  content: "\f040\00a0";
  color: #d7c896;
}

.markdown-body .admonition::after {
  content: normal;
}

.markdown-body .attention {
  border-left: 6px solid #a6d796;
}

.markdown-body .caution {
  border-left: 6px solid #d7a796;
}

.markdown-body .hint {
  border-left: 6px solid #96c6d7;
}

.markdown-body .danger {
  border-left: 6px solid #c25f77;
}

.markdown-body .question {
  border-left: 6px solid #96a6d7;
}

.markdown-body .note {
  border-left: 6px solid #d7c896;
}

.markdown-body .admonition>*:first-child {
  margin-top: 0 !important;
}

.markdown-body .admonition>*:last-child {
  margin-bottom: 0 !important;
}

/* progress bar*/
.markdown-body .progress {
  display: block;
  width: 300px;
  margin: 10px 0;
  height: 24px;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #ededed;
  position: relative;
  box-shadow: inset -1px 1px 3px rgba(0, 0, 0, .1);
}

.markdown-body .progress-label {
  position: absolute;
  text-align: center;
  font-weight: bold;
  width: 100%; margin: 0;
  line-height: 24px;
  color: #333;
  text-shadow: 1px 1px 0 #fefefe, -1px -1px 0 #fefefe, -1px 1px 0 #fefefe, 1px -1px 0 #fefefe, 0 1px 0 #fefefe, 0 -1px 0 #fefefe, 1px 0 0 #fefefe, -1px 0 0 #fefefe, 1px 1px 2px #000;
  -webkit-font-smoothing: antialiased !important;
  white-space: nowrap;
  overflow: hidden;
}

.markdown-body .progress-bar {
  height: 24px;
  float: left;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #96c6d7;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, .5), inset 0 -1px 0 rgba(0, 0, 0, .1);
  background-size: 30px 30px;
  background-image: -webkit-linear-gradient(
    135deg, rgba(255, 255, 255, .4) 27%,
    transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%,
    transparent 77%, transparent
  );
  background-image: -moz-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -ms-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -o-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
}

.markdown-body .progress-100plus .progress-bar {
  background-color: #a6d796;
}

.markdown-body .progress-80plus .progress-bar {
  background-color: #c6d796;
}

.markdown-body .progress-60plus .progress-bar {
  background-color: #d7c896;
}

.markdown-body .progress-40plus .progress-bar {
  background-color: #d7a796;
}

.markdown-body .progress-20plus .progress-bar {
  background-color: #d796a6;
}

.markdown-body .progress-0plus .progress-bar {
  background-color: #c25f77;
}

.markdown-body .candystripe-animate .progress-bar{
  -webkit-animation: animate-stripes 3s linear infinite;
  -moz-animation: animate-stripes 3s linear infinite;
  animation: animate-stripes 3s linear infinite;
}

@-webkit-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@-moz-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

.markdown-body .gloss .progress-bar {
  box-shadow:
    inset 0 4px 12px rgba(255, 255, 255, .7),
    inset 0 -12px 0 rgba(0, 0, 0, .05);
}

/* Multimarkdown Critic Blocks */
.markdown-body .critic_mark {
  background: #ff0;
}

.markdown-body .critic_delete {
  color: #c82829;
  text-decoration: line-through;
}

.markdown-body .critic_insert {
  color: #718c00 ;
  text-decoration: underline;
}

.markdown-body .critic_comment {
  color: #8e908c;
  font-style: italic;
}

.markdown-body .headeranchor {
  font: normal normal 16px octicons-anchor;
  line-height: 1;
  display: inline-block;
  text-decoration: none;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.headeranchor:before {
  content: '\f05c';
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 3px;
}

.markdown-body .task-list-item input {
  margin: 0 4px 0.25em -20px;
  vertical-align: middle;
}

/* Media */
@media only screen and (min-width: 480px) {
  .markdown-body {
    font-size:14px;
  }
}

@media only screen and (min-width: 768px) {
  .markdown-body {
    font-size:16px;
  }
}

@media print {
  .markdown-body * {
    background: transparent !important;
    color: black !important;
    filter:none !important;
    -ms-filter: none !important;
  }

  .markdown-body {
    font-size:12pt;
    max-width:100%;
    outline:none;
    border: 0;
  }

  .markdown-body a,
  .markdown-body a:visited {
    text-decoration: underline;
  }

  .markdown-body .headeranchor-link {
    display: none;
  }

  .markdown-body a[href]:after {
    content: " (" attr(href) ")";
  }

  .markdown-body abbr[title]:after {
    content: " (" attr(title) ")";
  }

  .markdown-body .ir a:after,
  .markdown-body a[href^="javascript:"]:after,
  .markdown-body a[href^="#"]:after {
    content: "";
  }

  .markdown-body pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
  }

  .markdown-body pre,
  .markdown-body blockquote {
    border: 1px solid #999;
    padding-right: 1em;
    page-break-inside: avoid;
  }

  .markdown-body .progress,
  .markdown-body .progress-bar {
    -moz-box-shadow: none;
    -webkit-box-shadow: none;
    box-shadow: none;
  }

  .markdown-body .progress {
    border: 1px solid #ddd;
  }

  .markdown-body .progress-bar {
    height: 22px;
    border-right: 1px solid #ddd;
  }

  .markdown-body tr,
  .markdown-body img {
    page-break-inside: avoid;
  }

  .markdown-body img {
    max-width: 100% !important;
  }

  .markdown-body p,
  .markdown-body h2,
  .markdown-body h3 {
    orphans: 3;
    widows: 3;
  }

  .markdown-body h2,
  .markdown-body h3 {
    page-break-after: avoid;
  }
}
</style><title>readme_vue</title></head><body><article class="markdown-body"><h1 id="vue-readme"><a name="user-content-vue-readme" href="#vue-readme" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>vue readme 前端框架</h1>
<p><a href="https://www.cnblogs.com/wenJiaQi/p/6528306.html">Vue.js 组件最佳实践</a><br />
<a href="https://pablohpsilva.github.io/vuejs-component-style-guide/#/">Vue.js Component Style Guide</a></p>
<p><a href="https://segmentfault.com/a/1190000010230843">VueJS 开发常见问题集锦</a><br />
<a href="https://blog.beard.ink/JavaScript/VueJS-开发常见问题集锦/">VueJS 开发常见问题集锦</a></p>
<p><a href="https://github.com/vuejs/awesome-vue">vuejs/awesome-vue: 🎉 A curated list of awesome things related to Vue.js</a><br />
<a href="http://teahour.fm/2015/08/16/vuejs-creator-evan-you.html">和 Vue.js 框架的作者聊聊前端框架开发背后的故事</a><br />
<a href="https://juejin.im/book/5a36661851882538e2259c0f/section/5a37bbb35188257d167a4d64">剖析 Vue.js 内部运行机制</a></p>
<h1 id="life-cycle"><a name="user-content-life-cycle" href="#life-cycle" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Life-Cycle 与组件销毁重建</h1>
<p>了解决 Vue 组件生命周期是理解 Vue 工作原理的基础，更新版本后 Vue 2.0 的生命周期函数的设计更合理了，以下是 Vue 2.0 和 1.0 的生命周期函数对比</p>
<table>
<thead>
<tr>
<th>vue 1.0</th>
<th>vue 2.0</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>init</td>
<td><code>beforeCreate</code></td>
<td>创建前，data和el都还未初始化</td>
</tr>
<tr>
<td>create</td>
<td><code>create</code></td>
<td>完成创建，data数据已初始化但el没有</td>
</tr>
<tr>
<td>beforeCompile</td>
<td><code>beforeMount</code></td>
<td>载入前，完成了data和el数据初始化，模板内容还未替换</td>
</tr>
<tr>
<td>compile/ready</td>
<td><code>mounted</code></td>
<td>载入后，载入后html已经渲染，ajax请求可以放在这个函数中</td>
</tr>
<tr>
<td>----</td>
<td><code>beforeUpdate</code></td>
<td>更新前，view层的数据变化前，不是data中的数据改变前</td>
</tr>
<tr>
<td>----</td>
<td><code>update</code></td>
<td>更新后</td>
</tr>
<tr>
<td>----</td>
<td><code>activated</code></td>
<td>keep-alive 组件激活时调用</td>
</tr>
<tr>
<td>----</td>
<td><code>deactivated</code></td>
<td>keep-alive 组件停用时调用</td>
</tr>
<tr>
<td>attached</td>
<td>----</td>
<td></td>
</tr>
<tr>
<td>detached</td>
<td>----</td>
<td></td>
</tr>
<tr>
<td>beforeDestroy</td>
<td><code>beforeDestroy</code></td>
<td>销毁前</td>
</tr>
<tr>
<td>destroyed</td>
<td><code>destroyed</code></td>
<td>销毁后，Dom元素存在但不受Vue控制</td>
</tr>
<tr>
<td>----</td>
<td><code>errorCaptured</code></td>
<td>错误捕捉</td>
</tr>
</tbody>
</table>
<p><code>$destory()</code> 函数可以触发组件销毁动作，清理过程只是在移除它和其它实例的连接，解除指令以及事件监听器，还有断掉虚拟dom和真实dom之间的联系。HTML 节点并没真正地没有回收，而且 <code>$on</code> 绑定的函数在 <code>$destory()</code> 过程也没有销毁掉，所以 HTML 还可以进行交互操作。</p>
<p>利用组件的挂载节点属性 <code>$el</code> 来清理组件的 HTML 元素，<code>vm.$el.remove()</code>，或者使用 Vue 1.0 提供的 <code>vm.$destroy( [remove] )</code> 方法，参数 <code>remove</code> 设置 true 直接解除 HTML 元素，此方法在 Vue 2.0 中已经弃了。参考<a href="https://vuejs.org/v2/guide/migration.html#vm-remove-removed">升迁 Vue 1.x</a>。</p>
<p>要销毁一类组件可以将组件名传入销毁方法，例如销毁所有 MessageBox 组件 <code>this.$destroy("MessageBox")</code>，这种销毁方法只对 this 指向的父组件下的子组件有效。</p>
<p>通过 <code>$once</code> 绑定生命同期事件：</p>
<pre><code>mounted: function () {
  this.$once('hook:beforeDestroy', function () {
    // vm.$destroy()
  })
}
</code></pre>
<p>在 <code>beforeDestroy</code> 事件中可以进行清理工作，如果通过 <code>vm.$el.remove()</code> 移除挂载节点，那么后续的组件在实例化时将不会再渲染得到视图。要保持后续实例化的组件拥有相同的视图，那么在销毁组件过程中就不能移除挂载节点，而是将节点隐藏，一个做法就是通过样式属性 <code>display</code> 来实现：</p>
<pre><code>this.$el.style.display = "none";
</code></pre>
<p>Vue 会自行处理这些 HMTL 节点，并且会对它们回收再利用。</p>
<p>PS: 使用 VueRouter 路由插件时，在路由切换的过程中，并不会触发组件的销毁过程，但视图渲染函数是会重新执行的。为了避免组件渲染受到 Vue 内部就地复用旧视图的影响，可以使用唯一的 <code>key</code> 属性值来保证视图被重新渲染。</p>
<p>在处理组件的销毁过程中可能需要到状态过度动画，可以使用 CSS 3 的 animation。也可以使用 <code>transition</code> 组件，参考 <a href="https://cn.vuejs.org/v2/guide/transitions.html">进入/离开 &amp; 列表过渡</a>，这里有许多富有创意的动画效果。</p>
<p>了解 Vue 的生命周期后，还有必要了解决以下这组 Vue 实例属性：</p>
<table>
<thead>
<tr>
<th>实例属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://vuejs.org/v2/api/#vm-data"><code>vm.$data</code></a></td>
<td>Vue 实例观察的数据对象，Vue 代理了对实例化参数中 data 对象属性的访问。</td>
</tr>
<tr>
<td><a href="https://vuejs.org/v2/api/#vm-props"><code>vm.$props</code></a></td>
<td>当前组件接收到的 props 对象。Vue 实例代理了对其 props 对象属性的访问。</td>
</tr>
<tr>
<td><a href="https://vuejs.org/v2/api/#vm-el"><code>vm.$el</code></a></td>
<td>Vue 实例使用的根 DOM 元素。</td>
</tr>
<tr>
<td><a href="https://vuejs.org/v2/api/#vm-options"><code>vm.$options</code></a></td>
<td>访问当前 Vue 实例的初始化传入的参数。</td>
</tr>
<tr>
<td><a href="https://vuejs.org/v2/api/#vm-parent"><code>vm.$parent</code></a></td>
<td>父实例引用，如果当前实例是顶级则返回 <code>undefined</code>。</td>
</tr>
<tr>
<td><a href="https://vuejs.org/v2/api/#vm-root"><code>vm.$root</code></a></td>
<td>当前组件树的根 Vue 实例。如果当前实例没有父实例，此实例将会是其自己。</td>
</tr>
<tr>
<td><a href="https://vuejs.org/v2/api/#vm-children"><code>vm.$children</code></a></td>
<td>当前实例的直接子组件。需要注意 <code>$children</code> 并不保证顺序，也不是响应式的。</td>
</tr>
<tr>
<td><a href="https://vuejs.org/v2/api/#vm-slots"><code>vm.$slots</code></a></td>
<td>访问被插槽分发的内容。具名插槽有其相应的属性名。默认的插槽的内容对应 <code>default</code> 属性，即通过 <code>v-slot:default</code> 绑定的内容，可以结合渲染函数编写组件。</td>
</tr>
<tr>
<td><a href="https://vuejs.org/v2/api/#vm-scopedSlots"><code>vm.$scopedSlots</code></a></td>
<td>用来访问作用域插槽。对于包括 默认 slot 在内的每一个插槽，该对象都包含一个返回相应 VNode 的函数。所有 $slots 都会作为函数暴露在 <code>$scopedSlots</code> 中。</td>
</tr>
<tr>
<td><a href="https://vuejs.org/v2/api/#vm-refs"><code>vm.$refs</code></a></td>
<td>返回通过 <code>ref</code> 特性注册的所有 DOM 元素和组件实例。</td>
</tr>
<tr>
<td><a href="https://vuejs.org/v2/api/#vm-isServer"><code>vm.$isServer</code></a></td>
<td>当前 Vue 实例是否运行于服务器，即服务端渲染的组件。</td>
</tr>
<tr>
<td><a href="https://vuejs.org/v2/api/#vm-attrs"><code>vm.$attrs</code></a></td>
<td>在组件内部用来访问父作用域传入的非 <code>props</code> 参数，<code>class</code> 和 <code>style</code> 除外。并且父组件可以通过 <code>v-bind="$attrs"</code> 方式传入，在创建高级别的组件时非常有用。</td>
</tr>
<tr>
<td><a href="https://vuejs.org/v2/api/#vm-listeners"><code>vm.$listeners</code></a></td>
<td>在组件内部用来访问父作用域中的 <code>v-on</code> 事件监听器，<code>.native</code> 修饰器的除外。它可以通过 <code>v-on="$listeners"</code> 传入内部组件——在创建更高层次的组件时非常有用。</td>
</tr>
</tbody>
</table>
<p>Vue 的核心内容有三大块，一是响应式的实现，二提模板编译实现，三是 Virtual DOM 机制实现。</p>
<p>模板编译 compile 可以分成三个阶段，最终得到的结果是一个渲染函数 <code>render</code>。解析阶段 parse 会用正则等方式解析模板中的指令、class、style等数据，形成抽象语法树 AST。优化阶段 optimize 的主要作用是标记 static 静态节点，在后面 update 更新视图时，有相应的 patch 过程，通过 diff 算法可以跳过静态节点，优化性能。生成阶段 generate 是将 AST 转化成渲染函数的过程，得到的结果是 render 函数的字符串以及 staticRenderFns 字符串。经过模板编译后，组件中就会存在产生 VNode 节点所需的渲染函数了。</p>
<p>Vue 内部使用 Virtual DOM 来管理视图树，就是以 JavaScript 对象 VNode 节点作为基础的树。通过对象属性来描述节点，在内存中抽象表达了真实 DOM 结构，但比浏览器的 DOM 操作更节能。另一方面，Virtual DOM 以 JavaScript 对象为基础不依赖真实平台环境，使得它天生具有跨平台的能力，全球最大的电商阿里就将它的跨平台能力应用到了 Weex 这个项目。</p>
<p>Vue 的数据响应机制检测到数据变化后，就会执行渲染函数，每个渲染函数 <code>render</code> 都会转化成 VNode 节点。 想要得到视图，最简单粗暴的方法就是直接解析这个新的 VNode 节点，然后通过浏览器提供的节点属性 <code>innerHTML</code> 生成。</p>
<p>Vue 内部当然不会这样做，对那些只修改了其中的一小块内容内容的节点，会经过特殊的 <code>patch</code> 方法处理，将新旧的 VNode 进行比较，经过 diff 算法得到差异结果，最后只需要将这些有差异的节点更新到浏览器对应 DOM 节点上，这个过程就涉及了 Vue 的就地利用机制，使用唯一的 <code>key</code> 可以保证组件的正确的渲染，而不受复用机制影响。</p>
<h1 id="vue-cli-3"><a name="user-content-vue-cli-3" href="#vue-cli-3" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Vue CLI 3 新特性</h1>
<h2 id="cli"><a name="user-content-cli" href="#cli" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>CLI 服务</h2>
<p><a href="https://cli.vuejs.org/zh/guide/cli-service.html#使用命令">CLI 服务</a></p>
<p>在 Vue CLI 3 项目 <code>@vue/cli-service</code> 模块安装了一个名为 <code>vue-cli-service</code> 的命令。可以通过 <code>npm run serve</code> 执行 npm scripts 的配置、或者从终端中以 <code>./node_modules/.bin/vue-cli-service</code> 访问这个命令。</p>
<pre><code>{
  "scripts": {
    "serve": "vue-cli-service serve",
    "build": "vue-cli-service build"
  }
}
</code></pre>
<p>最新版的 npm 应该已经自带 npx，也可以使用，调用命令参考：</p>
<pre><code>npm run serve
yarn serve
npx vue-cli-service serve
</code></pre>
<h3 id="vue-cli-service-serve"><a name="user-content-vue-cli-service-serve" href="#vue-cli-service-serve" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>vue-cli-service serve</h3>
<p>命令用法：<code>vue-cli-service serve [options] [entry]</code></p>
<pre><code>--open    在服务器启动时打开浏览器
--copy    在服务器启动时将 URL 复制到剪切版
--mode    指定环境模式 (默认值：development)
--host    指定 host (默认值：0.0.0.0)
--port    指定 port (默认值：8080)
--https   使用 https (默认值：false)
</code></pre>
<p>vue-cli-service serve 命令会启动一个开发服务器 (基于 webpack-dev-server) 并附带开箱即用的模块热重载 (Hot-Module-Replacement)。</p>
<p>除了通过命令行参数，你也可以使用 vue.config.js 里的 devServer 字段配置开发服务器。</p>
<p>命令行参数 [entry] 将被指定为唯一入口，而非额外的追加入口。尝试使用 [entry] 覆盖 config.pages 中的 entry 将可能引发错误。</p>
<h3 id="vue-cli-service-build"><a name="user-content-vue-cli-service-build" href="#vue-cli-service-build" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>vue-cli-service build</h3>
<p>命令用法：<code>vue-cli-service build [options] [entry|pattern]</code></p>
<p>选项：</p>
<pre><code>--mode        指定环境模式 (默认值：production)
--dest        指定输出目录 (默认值：dist)
--modern      面向现代浏览器带自动回退地构建应用
--target      app | lib | wc | wc-async (默认值：app)
--name        库或 Web Components 模式下的名字 (默认值：package.json 中的 "name" 字段或入口文件名)
--no-clean    在构建项目之前不清除目标目录
--report      生成 report.html 以帮助分析包内容
--report-json 生成 report.json 以帮助分析包内容
--watch       监听文件变化
</code></pre>
<p><code>vue-cli-service build</code> 会在 dist/ 目录产生一个可用于生产环境的包，带有 JS/CSS/HTML 的压缩，和为更好的缓存而做的自动的 vendor chunk splitting。它的 chunk manifest 会内联在 HTML 里。</p>
<p>这里还有一些有用的命令参数：</p>
<pre><code>--modern 使用现代模式构建应用，为现代浏览器交付原生支持的 ES2015 代码，并生成一个兼容老浏览器的包用来自动回退。
--target 允许你将项目中的任何组件以一个库或 Web Components 组件的方式进行构建。
--report 和 --report-json 会根据构建统计生成报告，它会帮助你分析包中包含的模块们的大小。
</code></pre>
<h3 id="-target"><a name="user-content--target" href="#-target" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>&ndash;target 指定构建目标</h3>
<p>可以通过 <code>--target</code> 选项指定不同的构建目标，它允许你将相同的源代码根据不同的用例生成不同的<a href="https://cli.vuejs.org/zh/guide/build-targets.html#应用">构建目标</a>，有 <code>应用模式</code>、 <code>库模式</code>、 <code>Web Components 组件模式</code>、 <code>异步 Web Components 模式</code> 四种。</p>
<p><strong>应用模式</strong>是默认的，在这个模式中 <code>index.html</code> 会注入资源和 resource hint，第三方库会被分到一个独立包以便更好的缓存，小于 4kb 的静态资源会被内联在 JavaScript 中，<code>public</code> 目录中的公共静态资源会被复制到输出目录中。</p>
<p><strong>库模式</strong>可以通过下面的命令将一个单独的入口构建为一个库：</p>
<pre><code>vue-cli-service build --target lib --name myLib [entry]
</code></pre>
<p>在库模式中，Vue 是外置的。这意味着包中不会有 Vue，即便你在代码中导入了 Vue。如果这个库会通过一个打包器使用，它将尝试通过打包器以依赖的方式加载 Vue；否则就会回退到一个全局的 Vue 变量。<code>[entry]</code> 指定的入口可以是一个 <code>.js</code> 或一个 <code>.vue</code> 文件。如果没有指定入口，则会使用 <code>src/App.vue</code>。</p>
<p>构建一个库会输出：</p>
<pre><code>dist/myLib.common.js   一个给打包器用的 CommonJS 包
dist/myLib.umd.js      一个直接给浏览器或 AMD loader 使用的 UMD 包
dist/myLib.umd.min.js  压缩后的 UMD 构建版本
dist/myLib.css         提取出来的 CSS，可以在 vue.config.js 中设置 css: { extract: false } 强制内联
</code></pre>
<p>当使用一个 <code>.vue</code> 文件作为入口时，你的库会直接暴露这个 Vue 组件本身，因为组件始终是默认导出的内容。</p>
<p>使用一个 <code>.js</code> 或 <code>.ts</code> 文件作为入口时，它可能会包含具名导出，所以库会暴露为一个模块。也就是导出的库必须在 UMD 构建中或在 CommonJS 构建中通过导出模块的 <code>default</code> 访问。</p>
<pre><code>window.yourLib.default // UMD
const myLib = require('mylib').default // CommonJS
</code></pre>
<p>如果你没有任何具名导出并希望直接暴露默认导出，你可以在 <code>vue.config.js</code> 中使用以下 webpack 配置：</p>
<pre><code>module.exports = {
  configureWebpack: {
    output: {
      libraryExport: 'default'
    }
  }
}
</code></pre>
<p><strong>Web Components 组件模式</strong>可以通过一个单独的入口构建：</p>
<pre><code>vue-cli-service build --target wc --name my-element [entry]
</code></pre>
<p>在 Web Components 模式中，Vue 是外置的。这意味着包中不会有 Vue，即便你在代码中导入了 Vue。 这个模式允许你的组件的使用者以一个普通 DOM 元素的方式使用这个 Vue 组件，注意这个包依赖了在页面上全局可用的 Vue，即需要页面中有一个可用的全局变量 Vue。。</p>
<pre><code>&lt;script src="https://unpkg.com/vue"&gt;&lt;/script&gt;
&lt;script src="path/to/my-element.js"&gt;&lt;/script&gt;

&lt;!-- 可在普通 HTML 中或者其它任何框架中使用 --&gt;
&lt;my-element&gt;&lt;/my-element&gt;
</code></pre>
<p>注意这里的入口应该是一个 <code>*.vue</code> 文件，Vue CLI 将会把这个组件自动包裹并注册为 Web Components 组件，无需在 <code>main.js</code> 里自行注册。</p>
<p>该构建将会产生一个单独的 JavaScript 文件并将所有的东西都内联起来。当这个脚本被引入网页时，会注册自定义组件 <code>&lt;my-element&gt;</code>，其使用 <code>@vue/web-component-wrapper</code> 包裹了目标的 Vue 组件。这个包裹器会自动代理属性、特性、事件和插槽。请查阅 <code>@vue/web-component-wrapper</code> 的文档了解更多细节。</p>
<p>可以使用一个 glob 表达式作为入口指定多个组件目标：</p>
<pre><code>vue-cli-service build --target wc --name foo 'src/components/*.vue'
</code></pre>
<p>当你构建多个 web component 时，<code>--name</code> 将会用于设置前缀，同时自定义元素的名称会由组件的文件名推导得出。比如一个名为 <code>HelloWorld.vue</code> 的组件携带 <code>--name foo</code> 将会生成的自定义元素名为 <code>&lt;foo-hello-world&gt;</code>。</p>
<p><strong>异步 Web Components 模式</strong>当指定多个 Web Components 组件作为目标时，这个包可能会变得非常大，并且用户可能只想使用你的包中注册的一部分组件。通过指定 <code>--target wc-async</code> 会生成一个 <code>code-split</code> 的包，带一个只提供所有组件共享的运行时，并预先注册所有的自定义组件小入口文件。组件真正的实现只会在页面中用到自定义元素相应的一个实例时按需获取：</p>
<pre><code>vue-cli-service build --target wc-async --name foo 'src/components/*.vue'
</code></pre>
<p>打包得到的文件包含一个入口文件和各组件实现的独立文件：</p>
<pre><code>File                Size                        Gzipped
dist/foo.0.min.js    12.80 kb                    8.09 kb
dist/foo.min.js      7.45 kb                     3.17 kb
dist/foo.1.min.js    2.91 kb                     1.02 kb
dist/foo.js          22.51 kb                    6.67 kb
dist/foo.0.js        17.27 kb                    8.83 kb
dist/foo.1.js        5.24 kb                     1.64 kb
</code></pre>
<p>在页面上使用时只需要引入 Vue 和这个入口文件即可：</p>
<pre><code>&lt;script src="https://unpkg.com/vue"&gt;&lt;/script&gt;
&lt;script src="path/to/foo.min.js"&gt;&lt;/script&gt;

&lt;!-- foo-one 的实现的 chunk 会在用到的时候自动获取 --&gt;
&lt;foo-one&gt;&lt;/foo-one&gt;
</code></pre>
<h3 id="vue-cli-service-inspect"><a name="user-content-vue-cli-service-inspect" href="#vue-cli-service-inspect" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>vue-cli-service inspect</h3>
<p>命令用法：<code>vue-cli-service inspect [options] [...paths]</code></p>
<p>选项：</p>
<pre><code>--mode    指定环境模式 (默认值：development)
</code></pre>
<p>你可以使用 <code>vue-cli-service inspect</code> 来审查一个 Vue CLI 项目的 webpack config。更多细节请查阅审查 webpack config。</p>
<h3 id="_1"><a name="user-content-_1" href="#_1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>查看所有的可用命令</h3>
<p>有些 CLI 插件会向 vue-cli-service 注入额外的命令。例如 @vue/cli-plugin-eslint 会注入 <code>vue-cli-service lint</code> 命令。以下命令查看所有注入的命令：</p>
<pre><code>npx vue-cli-service help
npx vue-cli-service help [command]
</code></pre>
<h2 id="fast-prototype"><a name="user-content-fast-prototype" href="#fast-prototype" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Fast-Prototype 快速原型开发</h2>
<p>使用 <code>vue serve</code> 和 <code>vue build</code> 命令对单个 <code>*.vue</code> 文件进行快速原型开发，但需要先额外安装一个全局的扩展：</p>
<pre><code>npm install -g @vue/cli-service-global
</code></pre>
<p>vue serve 的缺点就是它需要安装全局依赖，这使得它在不同机器上的一致性不能得到保证。因此这只适用于快速原型开发。</p>
<h3 id="vue-serve"><a name="user-content-vue-serve" href="#vue-serve" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>vue serve</h3>
<pre><code>Usage: serve [options] [entry]

[options]:
-o, --open  打开浏览器
-c, --copy  将本地 URL 复制到剪切板
-h, --help  输出用法信息
</code></pre>
<p>在开发环境模式下零配置为 <code>.js</code> 或 <code>.vue</code> 文件启动一个服务器</p>
<p><code>vue serve</code> 使用了和 <code>vue create</code> 创建的项目相同的默认设置 (webpack、Babel、PostCSS 和 ESLint)。它会在当前目录自动推导入口文件——入口可以是 <code>main.js</code>、<code>index.js</code>、<code>App.vue</code> 或 <code>app.vue</code> 中的一个，也可以显式地指定入口文件：</p>
<pre><code>vue serve MyComponent.vue
</code></pre>
<p>如果需要，你还可以提供一个 <code>index.html</code>、<code>package.json</code> 安装并使用本地依赖、甚至通过相应的配置文件配置 Babel、PostCSS 和 ESLint。</p>
<h3 id="vue-build"><a name="user-content-vue-build" href="#vue-build" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>vue build</h3>
<pre><code>Usage: build [options] [entry]

[options]:
-t, --target &lt;target&gt;  构建目标 (app | lib | wc | wc-async, 默认值：app)
-n, --name &lt;name&gt;      库的名字或 Web Components 组件的名字 (默认值：入口文件名)
-d, --dest &lt;dir&gt;       输出目录 (默认值：dist)
-h, --help             输出用法信息
</code></pre>
<p>在生产环境模式下零配置构建一个 <code>.js</code> 或 <code>.vue</code> 文件</p>
<p>你也可以使用 vue build 将目标文件构建成一个生产环境的包并用来部署：</p>
<pre><code>vue build MyComponent.vue
</code></pre>
<p>vue build 也提供了将组件构建成为一个库或一个 Web Components 组件的能力。</p>
<h2 id="vue-create"><a name="user-content-vue-create" href="#vue-create" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>vue create</h2>
<p><code>vue create</code> 命令创建一个由 <code>vue-cli-service</code> 提供支持的新项目，可以通过运行以下命令探索可选项：</p>
<pre><code>vue create --help

create [options] &lt;app-name&gt;

[options]:
-p, --preset &lt;presetName&gt;       忽略提示符并使用已保存的或远程的预设选项
-d, --default                   忽略提示符并使用默认预设选项
-i, --inlinePreset &lt;json&gt;       忽略提示符并使用内联的 JSON 字符串预设选项
-m, --packageManager &lt;command&gt;  在安装依赖时使用指定的 npm 客户端
-r, --registry &lt;url&gt;            在安装依赖时使用指定的 npm registry
-g, --git [message]             强制 / 跳过 git 初始化，并可选的指定初始化提交信息
-n, --no-git                    跳过 git 初始化
-f, --force                     覆写目标目录可能存在的配置
-c, --clone                     使用 git clone 获取远程预设选项
-x, --proxy                     使用指定的代理创建项目
-b, --bare                      创建项目时省略默认组件中的新手指导信息
-h, --help                      输出使用帮助信息
</code></pre>
<p>Vue CLI 3 开始支持项目管理图形界面 GUI，执行以下命令将开启 Web 服务提供的 Vue 项目管理器</p>
<pre><code>vue ui
</code></pre>
<p>Vue CLI 3 和旧版使用了相同的 vue 命令，所以 Vue CLI 2 即原来的 <code>vue-cli</code> 被新版命令覆盖了。如果需要使用旧版本的 <code>vue init</code> 功能，可以全局安装一个桥接工具，这样 <code>vue init</code> 的运行效果将会跟 <code>vue-cli@2.x</code> 相同：</p>
<pre><code>npm install -g @vue/cli-init
vue init webpack my-project
</code></pre>
<h1 id="vueconfigjs"><code>vue.config.js</code> 配置参考</h1>
<p><a href="https://cli.vuejs.org/zh/config/">Vue CLI 配置参考</a><br />
<a href="https://cli.vuejs.org/zh/guide/html-and-static-assets.html#插值">HTML 和静态资源</a><br />
[Configuration Reference | Vue CLI][<a href="https://cli.vuejs.org/config/#eslint">https://cli.vuejs.org/config/#eslint</a>]<br />
<a href="http://eslint.cn/docs/user-guide/configuring">Configuring ESLint - ESLint中文</a><br />
<a href="https://cli.vuejs.org/guide/deployment.html">Vue CLI Deployment</a><br />
<a href="https://cli.vuejs.org/zh/guide/deployment.html">Vue CLI 部署</a></p>
<p>Vue-CLI 3.5 版本中子目录发布图片路径问题，可以找到模块目录下的选项文件，修改 <code>publicPath</code> 即可，开发使用的服务器端口及 IP 地址也可以在 <code>devServer</code> 中配置。<code>cli-service</code> 自带 <code>options.js</code> 配置文件，其中可以配置公共资源目录，可以解决子目录发布时图片路径问题。这个内置配置文件不建议直接修改，可以在工程根目录下设置一个 <code>vue.config.js</code> 配置文件。</p>
<pre><code>// node_modules\@vue\cli-service\lib\options.js
publicPath: (process.env.NODE_ENV !== 'production'? "/":"/minis/vu/dist/"),
</code></pre>
<p>Vue 项目中有一个 public 文件夹，它用来存放那么不需要打包的资源文件，包括入口页面 index.html 等，这个文件夹下的所有资源会被直接拷贝到打包目录，即项目的 dist 目录下。</p>
<p>官方内置了一个CLI服务（@vue/cli-service），作为一个开发环境的依赖，局部安装在@vue/cli创建的项目中。如果你真想修改webpack的相关配置，可在项目的根目录下（和package.json同级）创建一个 <code>vue.config.js</code> 配置文件，@vue/cli-service会自动加载。也可直接使用package.json中的vue字段。</p>
<p><strong>publicPath</strong> 部署应用包时的基本 URL。用法和 webpack 本身的 output.publicPath 一致，但是 Vue CLI 在一些其他地方也需要用到这个值，所以请始终使用 publicPath 而不要直接修改 webpack 的 output.publicPath。这个值也可以被设置为空字符串 (&lsquo;&rsquo;) 或是相对路径 (&lsquo;./&rsquo;)，这样所有的资源都会被链接为相对路径，这样打出来的包可以被部署在任意路径，也可以用在类似 Cordova hybrid 应用的文件系统中。从 Vue CLI 3.3 起已弃用 baseUrl，请使用publicPath。</p>
<p><strong>outputDir</strong> 当运行 <code>vue-cli-service build</code> 时生成的生产环境构建文件的目录，默认值 <code>dist</code>。注意目标目录在构建之前会被清除，构建时传入 <code>--no-clean</code> 可避免清除旧文件。</p>
<p><strong>assetsDir</strong> 放置生成的静态资源 (js、css、img、fonts) 的目录，相对于 <code>outputDir</code>。</p>
<p><strong>indexPath</strong> 指定生成的 <code>index.html</code> 的输出路径，相对于 <code>outputDir</code>，也可以是一个绝对路径。</p>
<p><strong>lintOnSave</strong> 是否在每次保存时 lint 代码，在开发环境下通过 <code>eslint-loader</code> 加载。这个值会在 <code>@vue/cli-plugin-eslint</code> 被安装之后生效。设置为 <code>true</code> 时，<code>eslint-loader</code> 会将 lint 错误输出为编译警告。默认情况下，警告仅仅会被输出到命令行，且不会使得编译失败。如果你希望让 lint 错误在开发时直接显示在浏览器中，可以设置为  <code>error</code>。这会强制 <code>eslint-loader</code> 将 lint 错误输出为编译错误，同时也意味着 lint 错误将会导致编译失败。</p>
<p><strong>runtimeCompiler</strong> 设置为 true 支持运行时编译，这关就可以在 js 代码中使用模板字符串，Vue 会在运行时进行模板编译，这当然会降低运行效率并增加 js 文件大小。</p>
<p>在项目入口 <code>main.js</code> 中可以访问全局变量 <code>process</code> 得到配置信息，例如：</p>
<pre><code>process.env = {
    BASE_URL : "/minis/vu/dist/",
    NODE_ENV : "production"
}
</code></pre>
<p>可以在入口中将这些配置信息注入到 Vue 中，以供其它组件使用：</p>
<pre><code>// 将环境变量注入
Vue.prototype.processEnv = process.env;
</code></pre>
<p>BASE_URL - 对应 <code>vue.config.js</code> 中的 <code>publicPath</code>。<br />
NODE_ENV - 对应 <code>development</code>、<code>production</code> 或 <code>test</code> 中的一个，具体的值取决于应用运行的模式。</p>
<p>注意，除了两个配置信息，其它以 <code>VUE_APP_</code> 开头的变量会被 <code>webpack.DefinePlugin</code> 静态嵌入到客户端侧的包中，在项目入口中这样访问它们：</p>
<pre><code>console.log(process.env.VUE_APP_SECRET)
</code></pre>
<p>在构建过程中，<code>process.env.VUE_APP_SECRET</code> 将会被相应的值所取代。</p>
<p>所有解析出来的环境变量都可以在 <code>public/index.html</code> 中以 HTML 插值中介绍的方式使用。因为 <code>index.html</code> 文件被用作模板，所以你可以使用 lodash template 语法插入内容：</p>
<pre><code>&lt;%= VALUE %&gt; 用来做不转义插值；
&lt;%- VALUE %&gt; 用来做 HTML 转义插值；
&lt;% expression %&gt; 用来描述 JavaScript 流程控制。
</code></pre>
<p>除了被 html-webpack-plugin 暴露的默认值之外，所有客户端环境变量也可以直接使用，例如 <code>BASE_URL</code>：</p>
<pre><code>&lt;link rel="icon" href="&lt;%= BASE_URL %&gt;favicon.ico"&gt;
</code></pre>
<p>在 CSS 或 <code>*.vue</code> 文件中使用相对路径，即路径以英文句点开头引用一个静态资源时，该资源将会被包含进入 webpack 的依赖图中。在其编译过程中，所有诸如 <code>&lt;img src="..."&gt;</code>、<code>background: url(...)</code> 和 <code>CSS @import</code> 的资源 URL 都会被解析为一个模块依赖。在 Vue 内部通过 <code>file-loader</code> 用版本哈希值和正确的公共基础路径来决定最终的文件路径，再用 <code>url-loader</code> 将小于 4kb 的资源内联打包，以减少 HTTP 请求的数量。使用 JavaScript 代码引入资源的方法有以下两种方式：</p>
<pre><code>var img1 = require('../static/logo.png');
import img2 from '../static/logo.png';
</code></pre>
<p>配置文件内容参考：</p>
<pre><code>module.exports = {
  pages: {
    index: {
      // page 的入口
      entry: 'src/main.js',
      // 模板来源
      template: 'public/index.html',
      // 在 dist/index.html 的输出
      filename: 'index.html',
      // 当使用 title 选项时，
      // template 中的 title 标签需要是 &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;
      title: 'Index Page',
      // 在这个页面中包含的块，默认情况下会包含
      // 提取出来的通用 chunk 和 vendor chunk。
      chunks: ['chunk-vendors', 'chunk-common', 'index']
    },
    // 当使用只有入口的字符串格式时，
    // 模板会被推导为 `public/subpage.html`
    // 并且如果找不到的话，就回退到 `public/index.html`。
    // 输出文件名会被推导为 `subpage.html`。
    // subpage: 'src/subpage/main.js',
  },

  // whether to use eslint-loader
  lintOnSave: process.env.NODE_ENV == 'not_production',
  runtimeCompiler: true,
  publicPath: (process.env.NODE_ENV !== 'production'? "base/":"/minis/vu/dist/"),

  // Webpack 配置会被 webpack-merge 合并入最终的 webpack 配置。
  // https://cli.vuejs.org/zh/guide/webpack.html
  configureWebpack: config =&gt; {
    plugins: [
      new MyAwesomeWebpackPlugin()
    ]
  },

  devServer: {
    host: '0.0.0.0',
    port: 80,
    overlay: {
      warnings: true,
      errors: true
    }
    /*
    open: process.platform === 'darwin',
    host: '0.0.0.0',
    port: 8080,
    https: false,
    hotOnly: false,
    proxy: null, // string | Object
    before: app =&gt; {}
    */
  }
}
</code></pre>
<h1 id="eventbus-or-eventhub"><a name="user-content-eventbus-or-eventhub" href="#eventbus-or-eventhub" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>EventBus or EventHub</h1>
<p>组件间通信是一个基本功能需求，Vue 中组件间数据的传递大体有以下种方式：</p>
<ul>
<li>路由传值，在 Vue Router 路由中通过附加参数传值</li>
<li>父子组件 <code>props</code> 属性传值</li>
<li>Vuex 状态管理仓库 store</li>
<li>EventBus 编程模式</li>
</ul>
<p>在 Vue 2.0 中废弃了旧版的事件传递方式 <code>$dispath</code> 和 <code>$broadcast</code>。</p>
<p><code>$dispath</code> 是由子组件发起事件通知，向其父组件链中寻找对应的事件监听。直到找到最近的父组件的一个事件监听之后停止寻找，除非监听器返回 <code>true</code>，如果该子组件存在对该事件的监听也会被触发。</p>
<p><code>$broadcast</code> 则是由父组件向其子组件中传递消息，在子组件链路中找到事件监听之后，停止寻找，除非监听器返回 <code>true</code>。</p>
<p>因为基于组件树结构的事件流方式实在是让人难以理解，并且在组件结构扩展的过程中会变得越来越脆弱。并且$dispatch 和 $broadcast 也没有解决兄弟组件间的通信问题。</p>
<p>这些方法的最常见用途之一是父子组件的相互通信，使用 <code>v-on</code> 监听子组件上 <code>$emit</code> 触发的事件。然而，如果是跨多层父子组件通信的话，在组件上的 <code>$emit</code> 并没有什么用。而通过集中式的事件中间件则更灵活，这会让组件之间的通信非常顺利，即使是兄弟组件。</p>
<p>通过使用事件中心 EventBus，允许组件自由交流，无论组件处于组件树的哪一层。注意 EventBus 模式使用的 API 还是 <code>v-on</code>、 <code>$emit</code> 和 <code>$off</code>，只是触发这些 API 的上下文对应不是组件，而是顶级 Vue 实例，即在组件使用以下代码来触发、处理事件，只要保证触发事件和接收事件处理的上下文对象是同一个 Vue 实例就可以完成组件间的通信：</p>
<pre><code>this.$root.$on('demoEvent', (event)=&gt;{ 
    console.log(event);
});

this.$root.$emit('demoEvent', {type:'myevent'});
this.$root.$off('demoEvent');
</code></pre>
<p>通过 <code>$off</code> 来解除事件处理函数是一个好习惯。上面的代码就是 EventBus 的基本结构，但这种代码编写显得混乱了，特别是在大型项目中，这样的代码就会陷入一种无组织无管理的状态。因此，使用一个 EventBus 专用对象来组织这些代码显然是更好的选择。Vue 实例实现了一个事件分发接口，可以通过实例化一个空的 Vue 实例来实现这个目的。以下示例代码提供一个完整的范本：</p>
<p>一、在入口 <code>main.js</code> 中通过原型扩展给 Vue 初始化一个 <code>eventHub</code> 对象作为中央事件总线</p>
<pre><code>import Vue from 'vue'
Vue.prototype.eventHub = new Vue();
</code></pre>
<p>二、在 <code>Hello.vue</code> 组件中使用扩展的 Vue 的实例属性 <code>eventHub</code> 来触发事件和处理事件</p>
<pre><code>&lt;template&gt;
    &lt;div class="hello"&gt;
        &lt;h3&gt;{{name}} 组件&lt;/h3&gt;
        &lt;button @click="send"&gt;广播事件&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
    data(){
        return {
            name: 'Hello'
        }
    },
    methods:{
        send(){
            this.eventHub.$emit('helloEvent',this.name)
        }
    }
}
&lt;/script&gt;
</code></pre>
<p>三、在 <code>World.vue</code> 组件中订阅 <code>helloEvent</code> 事件，并在组件销毁时通过 <code>$off</code> 解除事件订阅</p>
<pre><code>&lt;template&gt;
    &lt;div class="world"&gt;
        &lt;h3&gt;{{name}} 组件&lt;/h3&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
    data(){
        return {
            name: 'World'
        }
    },
    mounted(){
        this.eventHub.$on('helloEvent',name =&gt; {
            this.name = name
        })
    },
    destroy(){
        this.eventHub.$off('helloEvent'})
    }
}
&lt;/script&gt;
</code></pre>
<p>可以将 EventBus 做成一个独立模块，这样在需要使用的组件中就需要手动加载它，如官方提供的 Todos 示例，其应用结构如下：</p>
<pre><code>Todos
├─ NewTodoInput
└─ Todo
   └─ DeleteTodoButton 触发事件的按钮组件
</code></pre>
<p>定义单独的事件中心来管理组件间的通信，<code>eventHub</code> 将在各处使用该事件中心，组件通过它来通信，这样组织的代码逻辑更清晰：</p>
<pre><code>var eventHub = new Vue()
</code></pre>
<p>然后在组件中，使用 <code>$emit</code>, <code>$on</code>, <code>$off</code> 分别来分发、监听、取消监听事件，最好在组件销毁前取消事件监听：</p>
<pre><code>// NewTodoInput ...
methods: {
  addTodo: function () {
    eventHub.$emit('add-todo', { text: this.newTodoText })
    this.newTodoText = ''
  }
}

// DeleteTodoButton ...
methods: {
  deleteTodo: function (id) {
    eventHub.$emit('delete-todo', id)
  }
}

// Todos 主程序部分 ...
created: function () {
  eventHub.$on('add-todo', this.addTodo)
  eventHub.$on('delete-todo', this.deleteTodo)
},
beforeDestroy: function () {
  eventHub.$off('add-todo', this.addTodo)
  eventHub.$off('delete-todo', this.deleteTodo)
},
methods: {
  addTodo: function (newTodo) {
    this.todos.push(newTodo)
  },
  deleteTodo: function (todoId) {
    this.todos = this.todos.filter(function (todo) {
      return todo.id !== todoId
    })
  }
}
</code></pre>
<h1 id="sfc-single-file-component"><a name="user-content-sfc-single-file-component" href="#sfc-single-file-component" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>SFC Single File Component 单文件组件概念</h1>
<p><a href="https://vuejs.org/v2/guide/single-file-components.html">Single File Components — Vue.js</a><br />
<a href="https://cn.vuejs.org/v2/guide/comparison.html">对比其他框架 — Vue.js</a><br />
[CSS 预处理器](<a href="https://cli.vuejs.org/zh/guide/css.html">https://cli.vuejs.org/zh/guide/css.html</a>）</p>
<p>将脚本模板样式三合为一，以单个 vue 文件来编写组件，<code>script</code>、 <code>style</code> 可以通过 <code>src</code> 引入外部文件，也可以直接编写代码。</p>
<pre><code>&lt;!-- my-component.vue --&gt;
&lt;template&gt;
  &lt;div&gt;This will be pre-compiled&lt;/div&gt;
&lt;/template&gt;
&lt;script src="./my-component.js"&gt;&lt;/script&gt;
&lt;style src="./my-component.css"&gt;&lt;/style&gt;
</code></pre>
<p>单文件组件让你可以在同一个文件里完全控制 CSS，将其作为组件代码的一部分，要使用 stylus 样式语法，可以添加 <code>lang="stylus"</code> 属性。</p>
<pre><code>&lt;style scoped&gt;
  @media (min-width: 250px) {
    .list-container:hover {
      background: orange;
    }
  }
&lt;/style&gt;
</code></pre>
<p>这个可选 scoped 属性会自动添加一个唯一的属性 (比如 data-v-21e5b78) 为组件内 CSS 指定作用域，编译的时候 <code>.list-container:hover</code> 会被编译成类似 </p>
<pre><code>.list-container[data-v-21e5b78]:hover
</code></pre>
<p>Vue CLI 项目天生支持 PostCSS、CSS Modules 和包含 Sass、Less、Stylus 在内的预处理器，具体内容参考官方文档。</p>
<h1 id="ajax-vue-resource-axios-v-for"><a name="user-content-ajax-vue-resource-axios-v-for" href="#ajax-vue-resource-axios-v-for" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Ajax Vue-Resource &amp; Axios v-for</h1>
<p>Vue 2.0之后，作者就宣告不再对 Vue-Resource 更新，并且 Vue-Resource 不支持 SSR，所以推荐使用 Axios, 在服务端和客户端可以同时使用。注意 Vue-Resource 是 Vue 插件，而 Axios 不是，不能用 <code>Vue.use()</code> 的方式使用 Axios，但可以通过原型扩展的方式使用 Axios。</p>
<pre><code>&lt;script src="https://cdn.bootcss.com/vue-resource/1.5.1/vue-resource.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="http://vuejs.org/js/vue.min.js"&gt;&lt;/script&gt;
&lt;link rel="stylesheet" type="text/css" href="http://unpkg.com/iview/dist/styles/iview.css"&gt;
&lt;script type="text/javascript" src="http://unpkg.com/iview/dist/iview.min.js"&gt;&lt;/script&gt;

&lt;div id="app"&gt;
    &lt;i-button @click="show"&gt;Click me!&lt;/i-button&gt;
    &lt;Modal v-model="visible" title="Welcome"&gt;Welcome {{message}} to iView&lt;/Modal&gt;
    &lt;div class="album"&gt;
        &lt;img class="item" v-for="item in list" v-bind:src="'&lt;?php echo CONF::UPLOADPATH ?&gt;/'+item.thumb"&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
    new Vue({
        el: '#app',
        data: {
            list:[],
            message:"...",
            visible: false
        },
        methods: {
            show: function () {
                this.visible = true;
                var url = '/minis/index.php/album/index/0/20/1?ajax=true';
                // this.$http.get(url).then(function(res){ var a = res.body or res.bodyText ...
                // this.$http.jsonp(url,{'method':"POST"}).then(function(res){
                this.$http.post(url,{arg:url},{emulateJSON:true}).then(function(res){
                    console.log("ajax for json", res);
                    this.list = res.body.data.list;
                    this.message = res.body.msg;
                },function(){
                    console.log('请求失败处理');
                });
            }
        }
    })
&lt;/script&gt;
</code></pre>
<h1 id="vue-plugin-axios"><a name="user-content-vue-plugin-axios" href="#vue-plugin-axios" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Vue Plugin 与 Axios 非插件</h1>
<p>Vue 插件机制是我见过最简单的了，只需要一个安装方法。插件使用 Vue.use() 进行全局引入，可以在其他组件中使用，通过插件对 Vue 的扩展可以实现 Vue 没有提供的功能，如 VueRouter 路由插件</p>
<pre><code>import VueRouter from 'vue-router'
Vue.use(VueRouter)
</code></pre>
<p>非插件不能使用以上方式引用，像 Ajax 工具 Axios，可以通过原型扩展引入</p>
<pre><code>import Vue from 'vue'
import axios from 'axios'

Vue.prototype.axios = axios;

new Vue({
    el: '#app',
    render:h =&gt; h(App),
    created:()=&gt;{ 
        this.axios.get('/url').then((res)=&gt;{
            // load res.data from url
        }).catch();
    }
})
</code></pre>
<p>实现一个插件，只要给插件添加一个 install 方法，Vue 负责执行它将 Vue 作为参数传入，插件安装方法中的 <code>options</code> 参数就是 <code>Vue.use()</code> 传入的参数。通过扩展 Vue.propotype 原型链，可以实现需要的插件功能，如下实现一个多语言转换插件 <code>i18n.js</code>。</p>
<pre><code>let $lang = [];
// $lang["language_key"] = "The actual message to be shown";

$lang["Hello View Engine!"] = "你好 Vue Engine！";
$lang["Welcome to Minis..."] = "欢迎来到 Minis！";
$lang["No file deleted!"] = "注意文件没有删除！";

export default {
    install (Vue, options) {
        // 1. add global method or property
        Vue.lang = function (token) {
            return token;
        }

        // 2. add a global asset
        Vue.directive('my-directive', {
            bind (el, binding, vnode, oldVnode) {
            // some logic ...
            }
        })

        // 3. inject some component options
        Vue.mixin({
            created: function () {
                // console.log("i18N installed...");
            }
        })

        // 4. add an instance method
        Vue.prototype.lang = function (token) {
            console.log("i18N.laning...", token, $lang[token]);
            if ($lang[token]) return $lang[token];
            return token;
        }

        Vue.prototype.toast = function (token) {
            console.log("i18N.toast...", token, $lang[token]);
            if ($lang[token]) return alert($lang[token]);
            return alert(token);
        }

    }
}
</code></pre>
<p>在项目入口导入并安装插件后，就可以使用了，如 <code>this.lang('ABC')</code></p>
<pre><code>import i18N from './i18N.js'
Vue.use(i18N, {text:"myoption"});
</code></pre>
<h1 id="vue-router"><a name="user-content-vue-router" href="#vue-router" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Vue Router 路由插件</h1>
<p>Vue Router 是 Vue.js 官方的路由管理器插件，它和 Vue.js 的核心深度集成，让构建单页面应用 SPA 变得易如反掌，包含的功能有：</p>
<ol>
<li>嵌套的路由/视图表</li>
<li>模块化的、基于组件的路由配置</li>
<li>路由参数、查询、通配符</li>
<li>基于 Vue.js 过渡系统的视图过渡效果</li>
<li>细粒度的导航控制</li>
<li>带有自动激活的 CSS class 的链接</li>
<li>HTML5 历史模式或 hash 模式，在 IE9 中自动降级</li>
<li>自定义的滚动条行为</li>
</ol>
<p>在工程目录执行命令安装 vue-router 插件</p>
<pre><code>npm install vue-router
</code></pre>
<p>在工程入口中使用它，通过 Vue.use() 安装路由插件，然后将路由实例以 roter 参数传入 Vue 实例或组件，以下示例代码中路由配置 routes 为空，所以路由视图并不会得到匹配的内容：</p>
<pre><code>import Vue from 'vue'
import VueRouter from 'vue-router'

Vue.use(VueRouter)

const router = new VueRouter({ routes:[] });

new Vue({
    router:router,
    ...
});
</code></pre>
<h2 id="vue-router_1"><a name="user-content-vue-router_1" href="#vue-router_1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Vue Router 实现原理</h2>
<p><a href="https://blog.csdn.net/vv_bug/article/details/82795248">vue-router全解析一</a><br />
<a href="https://blog.csdn.net/vv_bug/article/details/82766049">vue-router全解析二</a><br />
<a href="https://segmentfault.com/a/1190000012312441">Vue2.0三——Vue-router</a></p>
<p>浏览器 <code>history</code> 对象提供了方法来处理历史记录，<code>pushState()</code> 用来向浏览器插入一条历史记录，<code>replaceState()</code> 方法用来替换浏览器中的一条历史记录。参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/History_API">History_API</a>，这两个方法可以在不重新加载页面的情况下修改location跟浏览器的历史记录。</p>
<p>如下，一个完整的页面地址由协议 <code>https</code>、主机名 <code>www.host.com:80</code>、页面地址 <code>/static/index.html</code>、查询字符串 <code>?query=123</code> 和 hash <code>#/user/110</code> 组成，注意 Web 默认端口 80 通常是省略不写的。</p>
<pre><code>https://www.host.com/static/index.html?query=123#/user/110
</code></pre>
<p>通过浏览器打印以下变量可知道</p>
<pre><code>location.href   "https://www.host.com/static/index.html?query=123#/user/110"
location.search "?query=123"
location.hash   "#/user/110"
</code></pre>
<p>通过给 <code>location.href</code> 一个新地址，页面就会刷新跳到指定的地址上，这相当点击一个超链接进入新页面。但是，如果新地址只有hash这部分不同，其它都一样的情况就不同了。地址整体是有变化的，但页面不会刷新跳转。通过脚本可以检测到这种变化，那将这种变化以一定的规则和需要呈现的视图绑定，这就是 Vue Router 干的事。Vue Router 工作流程中主要包含路由配置项、路由视图，配置项包含 <code>path</code> 属性用来配置地址栏的字符串，命中后就会将配置项 <code>component</code> 指定的组件渲染到路由视图上，页面显示相应的内容。匹配到路由配置后，路由链接标签 <code>router-link</code> 会增加 CSS 样式类 <code>.router-link-active</code>，并且当前被点击的标签还会添加 <code>.router-link-exact-active</code> 样式类，多个路由标签可能匹配到同一个路由配置。</p>
<p>例如，点击这样一个 Vue Router 路由链接:</p>
<pre><code>&lt;router-link to="/user/110"&gt;Go to User&lt;/router-link&gt;
</code></pre>
<p>浏览器地址栏就会改变hash部分：</p>
<pre><code>#/user/110
</code></pre>
<h2 id="navigation-guards"><a name="user-content-navigation-guards" href="#navigation-guards" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Navigation Guards 导航守卫</h2>
<p>Vue Router 提供强大的编程能力，通过 <code>go()</code>、 <code>push()</code>、 <code>replace()</code> 三个导航方法实现路由切换。也可以在路由执行切换过程中，使用<strong><a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html">导航守卫</a></strong>功能，通过各种守卫函数实现路由拦截处理。守卫是异步解析执行的，此时导航在所有守卫 resolve 完之前一直处于 等待中。这些守卫函数分成五种，<strong><a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#全局前置守卫">全局前置守卫</a></strong> <code>beforeEach()</code>、 <strong><a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#全局解析守卫">全局解析守卫</a></strong> <code>beforeResolve()</code>、 <strong><a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#全局后置钩子">全局后置钩子</a></strong> <code>afterEach()</code>、 <strong><a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#路由独享的守卫">路由独享的守卫</a></strong>、 <strong><a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#组件内的守卫">组件内的守卫</a></strong>。</p>
<p>每个守卫方法接收三个参数：</p>
<ul>
<li>to: Route: 即将要进入的目标 路由对象</li>
<li>from: Route: 当前导航正要离开的路由</li>
<li>next: Function: 一定要调用该方法来 resolve 这个钩子。</li>
</ul>
<p>给 <code>next()</code> 函数传入不同的参数效果各有不同：</p>
<p><code>next()</code> 空参数表示直接进行管道中的下一个钩子即其它守卫函数。如果全部钩子执行完了，则导航的状态就是 confirmed 确认的，会进入视图渲染流程。</p>
<p><code>next(false)</code> 中断当前的导航，检测到数据未保存可以使用。如果浏览器的 URL 改变了，那么 URL 地址会重置到 from 路由对应的地址，即使是手动改变了 URL。</p>
<p><code>next('/')</code>、<code>next({ path: '/' })</code> 会导航到新的地址并中断当前触发的导航，有点像生定向的功能。可以向 next 传递任意位置对象，且允许设置诸如 <code>replace: true</code>、<code>name: 'home'</code> 之类的选项以及任何用在 <code>&lt;router-link&gt;</code> 的 <code>to</code> 属性或 <code>push()</code> 方法中的选项。</p>
<p><code>next(error)</code> Vue 2.4.0+ 引入，如果传入参数是一个 <code>Error</code> 实例，则终止导航且错误会被传递给 <code>onError()</code> 注册过的回调。</p>
<p>当一个导航动作触发时，全局前置守卫按照创建顺序调用，注意，不同的组件都可以定义自己的路由器。在 Vue 2.5.0+ 可以使用全局解析守卫，它会在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后被调用。注意全局后置钩子不会接受 next 函数也不能改变导航本身。</p>
<pre><code>const router = new VueRouter({ ... })

router.beforeResolve((to, from, next) =&gt; { ... })
router.beforeEach((to, from, next) =&gt; { ... })
router.afterEach((to, from) =&gt; { ... })
</code></pre>
<p>路由独享的守卫在路由配置上直接定义 <code>beforeEnter</code>，这些守卫与全局前置守卫的方法参数是一样的。</p>
<pre><code>const router = new VueRouter({
    routes: [
        { path: '/foo', component: Foo, beforeEnter: (to, from, next) =&gt; { ... } }
    ]
})
</code></pre>
<p>组件守卫，在 enter 守卫 <code>beforeRouteEnter()</code> 执行时组件实例还没被创建，因为对应路由被 confirm 前还未进入组件渲染程序，不能获取组件实例 <code>this</code>。可以通过传一个回调给 next 来访问组件实例。在导航被确认的时候会执行回调，并且把组件实例作为回调方法的参数，注意，这是唯一支持给 next 传递回调守卫函数。在当前路由改变，并且该组件被复用时会调用 <code>beforeRouteUpdate()</code>，举例来说，对于一个带有动态参数 <code>/foo/:id</code> 的路由配置，在 <code>/foo/1</code> 和 <code>/foo/2</code> 之间跳转，会渲染同样的 <code>Foo</code> 组件，因此组件实例会被复用，而这个钩子就会在这个情况下被调用，此时可以访问组件实例 <code>this</code>。导航离开该组件的对应路由时调用 leave 守卫 <code>beforeRouteLeave()</code>。</p>
<pre><code>const Foo = {
    template: `...`,
    beforeRouteEnter (to, from, next) { 
        // ...NO THIS...
        next(vm =&gt; {
            // CALLBACK for this
        })
    },
    beforeRouteUpdate (to, from, next) { ... },
    beforeRouteLeave (to, from, next) { ... }
}
</code></pre>
<p>完整的导航解析流程：</p>
<ul>
<li>通过路由组件 <code>&lt;router-link&gt;</code> 触发导航。</li>
<li>在失活的组件内的 <code>beforeRouteLeave()</code> 守卫函数被调用。</li>
<li>全局前置守卫 <code>beforeEach()</code> 被调用。</li>
<li>在重用的组件里调用 <code>beforeRouteUpdate()</code> 守卫 (Vue 2.2+)。</li>
<li>在路由配置里调用 <code>beforeEnter()</code>。</li>
<li>解析异步路由组件。</li>
<li>在被激活的组件里调用 <code>beforeRouteEnter()</code>。</li>
<li>调用全局解析守卫 <code>beforeResolve()</code> (Vue 2.5+)。</li>
<li>导航被确认。</li>
<li>调用全局的 <code>afterEach()</code> 钩子。</li>
<li>触发 DOM 更新。</li>
<li>用创建好的实例调用 <code>beforeRouteEnter()</code> 守卫中传给 <code>next()</code> 的回调函数。</li>
</ul>
<h2 id="spa"><a name="user-content-spa" href="#spa" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>SPA单面应用</h2>
<p>DEMO 展示要点</p>
<ul>
<li>VueRouter 的基本使用方法</li>
<li>命名路由，在路由配置项中使用了 <code>name</code> 属性</li>
<li>路由视图，路由出口组件即生成路由结果的视图 <code>&lt;router-view&gt;</code></li>
<li>命名视图，给 <code>&lt;router-view&gt;</code> 组合设置 <code>name</code> 属性，默认值为 default</li>
<li>使用命名视图，在路由配置中设置 <code>components</code> 而非 <code>component</code></li>
<li>嵌套路由，通过配置 <code>children</code> 给路由配置子级路由项目</li>
<li>重定向路由配置项，将原本 <code>path</code> 匹配的路由地址重新路由到 <code>redirect</code> 属性指定的地址，可以使用命名路由或一个动态返回重定向目标的方法</li>
<li>路由链接组件 <code>&lt;router-link&gt;</code> 会渲染成a标签，点击 <code>&lt;router-link :to="..."&gt;</code> 等同于调用 <code>router.push("...")</code>。</li>
<li>使用命名路由 <code>&lt;router-link :to="{ name: 'user', params: { userId: 123 }}"&gt;User&lt;/router-link&gt;</code></li>
<li>
<p>编程式的导航 </p>
<p>router.go(n) 类似 window.history.go(n)。<br />
router.push(location, onComplete?, onAbort?)<br />
router.replace(location, onComplete?, onAbort?) 相当声明式 <router-link :to="..." replace></p>
<p>router.push(&lsquo;home&rsquo;) // 字符串<br />
router.push({ path: &lsquo;home&rsquo; }) // 对象<br />
router.push({ name: &lsquo;user&rsquo;, params: { userId: 123 }}) // 命名的路由<br />
router.push({ path: &lsquo;register&rsquo;, query: { plan: &lsquo;private&rsquo; }}) // 带查询参数，变成 /register?plan=private</p>
</li>
</ul>
<p>参考<a href="https://router.vuejs.org/zh/guide/essentials/nested-routes.html">路由嵌套</a></p>
<pre><code>&lt;script src="https://unpkg.com/vue/dist/vue.js"&gt;&lt;/script&gt;
&lt;script src="https://unpkg.com/vue-router/dist/vue-router.js"&gt;&lt;/script&gt;
&lt;style&gt;
    .button { padding:2px; text-decoration: none; background:#00CAFF; border:1px solid #cccccc;}
    .button:hover {color:#fff;}
    .router-link-active {background:#FfBb00;}
&lt;/style&gt;

&lt;div id="app"&gt;
  &lt;h1&gt;Hello App!&lt;/h1&gt;
  &lt;p&gt;
    &lt;!-- 使用 router-link 组件来导航，它会被渲染成一个 `&lt;a&gt;` 标签，`to` 属性指定链接 --&gt;
    &lt;!-- IE天生天然残缺，不支持反引号，`/user/${id}/${name}`这样的模板字符串就不能使用了 --&gt;
    &lt;router-link class="button" to="/foo"&gt;Go to Foo&lt;/router-link&gt;
    &lt;router-link class="button" to="/bar"&gt;Go to Bar&lt;/router-link&gt;
    &lt;router-link class="button" :to="'/user/'+id+'/'+name"&gt;Go to User1 View&lt;/router-link&gt;
    &lt;router-link class="button" :to="'/user/112/Jimbo'"&gt;Go to User2 View&lt;/router-link&gt;
    &lt;button class="button" @click="goBack"&gt;Go Back&lt;/button&gt;
    &lt;span&gt;Watching {{stamp}}&lt;/span&gt;
  &lt;/p&gt;
  &lt;!-- 路由视图 路由出口 路由匹配到的组件将渲染在这里 --&gt;
  &lt;router-view&gt;&lt;/router-view&gt;
  &lt;!-- 命名视图 --&gt;
  &lt;router-view name="secondary"&gt;&lt;/router-view&gt;
&lt;/div&gt;

&lt;script&gt;
    // 1. 定义组件。组件也可以通过 Vue.extend() 创建或者是一个组件配置对象
    const Foo  = { template: '&lt;div&gt;foo view&lt;/div&gt;' }
    const Bar  = { template: '&lt;div&gt;bar view&lt;/div&gt;' }
    const User = { 
        template:'&lt;div&gt;' + // 因为组件模板只能有一个顶级元素所以这里要使用div包裹两个子元素
                '   &lt;div&gt;Hello {{ $route.params.id }}&lt;/div&gt;' +
                '   &lt;router-view&gt;&lt;/router-view&gt;' + // 组件中使用路由视图用于渲染子路由匹配到的组件
                '&lt;/div&gt;',
        watch: {  // 添加 watch 方法对路由变化作出响应...
            $route:function (to, from) { 
                console.log("route change ",to," &lt;= ",from);
                this.name = to+" &lt;= "+from;
            }
        },
        beforeRouteEnter:function (to, from, next) { // to, from 都是 $route 实例
            console.log("before route enter ", to, " &lt;= ", from);
            next();
        },
        beforeRouteUpdate:function (to, from, next) { // 2.2 中引入的导航守卫
            // react to route changes...
            // don't forget to call next()
            console.log("before route update ", to, " &lt;= ", from);
            next();
        }
    }

    // 2. 配置组件的路由，每个路由应该映射一个组件
    const routes = [
        { path: '/foo', component: Foo },
        { path: '/bar', component: Bar, name:"toBar" }, // 设置 name 属性来配置一个命名路由
        { path: '/user/:id', component: User,  // 动态路径参数 以冒号开头
            children:[ // 嵌套路由 子视图内容会渲染到 User 组件中的 &lt;router-view&gt;&lt;/router-view&gt;
                { path:'', component:User }, // 子路由空路径时匹配上一级路由 /user/:id
                { path:'jeango', component:Foo }, // 匹配 /user/:id/jeango
                { path:'jimbo',  component:Bar }
            ]
        }
    ]

    // 3. 以 `routes` 配置创建 router 实例，{ routes } 是ES6缩写，相当于 {routes: routes}
    const router = new VueRouter({ routes:routes })

    // 4. 创建vue实例和挂载根实例。启动应用！
    const app = new Vue({
        router:router,
        data:{name:"Jeango", id:110, stamp: + new Date()},
        watch: { // 监视参数变化
            stamp:function () {
                console.log('watching', this.$route);
                return this.$route.params.name
            }
        },
        methods: {
            goBack:function () {
                this.stamp = +new Date(); // 更新相间数据触发watch事件
                window.history.length &gt; 1
                ? this.$router.go(-1)
                : this.$router.push('/')
            }
        }
    }).$mount('#app')

&lt;/script&gt;
</code></pre>
<h2 id="named-route"><a name="user-content-named-route" href="#named-route" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>named-route 命名路由</h2>
<p><a href="https://router.vuejs.org/zh/guide/essentials/named-routes.html">命名路由</a></p>
<p>通过一个名称来标识一个路由显得更方便一些，特别是在链接一个路由，或者是执行一些跳转的时候。</p>
<pre><code>const router = new VueRouter({
  routes: [
    {
      path: '/user/:userId',
      name: 'user',
      component: User
    }
  ]
})
</code></pre>
<p>要链接到一个命名路由，可以给 router-link 的 to 属性传一个对象：</p>
<pre><code>&lt;router-link :to="{ name: 'user', params: { userId: 123 }}"&gt;User&lt;/router-link&gt;
</code></pre>
<p>这跟代码调用 router.push() 是一回事：</p>
<pre><code>router.push({ name: 'user', params: { userId: 123 }})
</code></pre>
<p>这两种方式都会把路由导航到 <code>/user/123</code> 路径。</p>
<h2 id="named-view-component-vs-components"><a name="user-content-named-view-component-vs-components" href="#named-view-component-vs-components" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>named-view 命名视图与嵌套 component vs components</h2>
<p><a href="https://router.vuejs.org/zh/api/#name"><code>&lt;router-view&gt;</code> Props</a><br />
<a href="https://router.vuejs.org/zh/guide/essentials/named-views.html">命名视图</a></p>
<p>如果 <code>&lt;router-view&gt;</code> 设置了名称，则会渲染对应的路由配置中 <code>components</code> 下的相应组件。查看 命名视图 中的例子。</p>
<p>有时候想同时展示多个视图，而不是嵌套展示，例如创建一个布局，有侧栏导航 sidebar 和主内容 main  两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 <code>router-view</code> 没有设置名字，那么默认为 <code>default</code>。</p>
<pre><code>&lt;router-view class="view one"&gt;&lt;/router-view&gt;
&lt;router-view class="view two" name="a"&gt;&lt;/router-view&gt;
&lt;router-view class="view three" name="b"&gt;&lt;/router-view&gt;
</code></pre>
<p>一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件，确保正确使用 <code>components</code> 配置：</p>
<pre><code>const router = new VueRouter({
  routes: [
    {
      path: '/',
      components: {
        default: Foo,
        a: Bar,
        b: Baz
      }
    }
  ]
})
</code></pre>
<p>我们也有可能使用命名视图创建嵌套视图的复杂布局。这时你也需要命名用到的嵌套 router-view 组件。我们以一个设置面板为例：</p>
<p>假设 UserSettings 组件的 <code>&lt;template&gt;</code> 部分是类似下面的这段代码：</p>
<pre><code>&lt;!-- UserSettings.vue --&gt;
&lt;div&gt;
  &lt;h1&gt;User Settings&lt;/h1&gt;
  &lt;NavBar/&gt;
  &lt;router-view/&gt;
  &lt;router-view name="helper"/&gt;
&lt;/div&gt;
</code></pre>
<p>然后你可以用这个路由配置完成该布局：</p>
<pre><code>{
    path: '/settings',
    // 你也可以在顶级路由就配置命名视图
    component: UserSettings,
    children: [
        { path: 'emails', component: UserEmailsSubscriptions },
        { path: 'profile', components: {default: UserProfile, helper: UserProfilePreview }
    }]
}
</code></pre>
<p>RouteConfig 的类型定义：</p>
<pre><code>declare type RouteConfig = {
  path: string;
  component?: Component;
  name?: string; // 命名路由
  components?: { [name: string]: Component }; // 命名视图组件
  redirect?: string | Location | Function;
  props?: boolean | Object | Function;
  alias?: string | Array&lt;string&gt;;
  children?: Array&lt;RouteConfig&gt;; // 嵌套路由
  beforeEnter?: (to: Route, from: Route, next: Function) =&gt; void;
  meta?: any;

  // 2.6.0+
  caseSensitive?: boolean; // 匹配规则是否大小写敏感？(默认值：false)
  pathToRegexpOptions?: Object; // 编译正则的选项
}
</code></pre>
<h2 id="vue"><a name="user-content-vue" href="#vue" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Vue 响应式基本原理</h2>
<p>Vue 实现双向数据绑定的原理就是利用 ECMAScript 5.1 规范中定义的 [Object.defineProperty()] 属性定义接口，这个方法用来定义对象属性描述符。对象属性描述符有<strong>数据描述符</strong>和<strong>存取描述符</strong>。数据描述符是一个具有值的属性，可以配置读写性 <code>writable</code>。存取描述符是由 Getter、Setter 函数描述的属性，即对属性读写时的关联函数。描述符必须是这两种形式之一，不能同时是两者，简单地说就是 <code>get</code>、<code>set</code> 和 <code>value</code>、<code>writable</code>不能同时定义。这个属性定义接口在 Internet Explorer 9 中才被支持，IE8 虽然实现这个接口但只能在 DOM 对象上使用，这就是 Vue 不支持旧版 IE8 的原因。</p>
<p>当属性设置为 <code>writable</code> 为 false 时，该属性处于只读状态，对属性赋值时不会发生错误也不会改变原值。<code>enumerable</code> 定义了对象的属性是否可以在 for-in 循环和 Object.keys() 中被枚举，默认为 false。使用 <code>oo.anotherProperty=123</code> 这样直接赋值的方式创建对象的属性，则这个属性是可以被枚举的，<code>enumerable</code> 为 true。<code>configurable</code> 特性表示对象的属性是否可以被重新配置，以及除 <code>value</code> 和 <code>writable</code> 特性外的其他特性是否可以被修改，也就是说，当属性定义为不可配置时，对 <code>enumerable</code> 或 Getter、Setter 方法重新定义时会抛出异常。</p>
<pre><code class="javascript">    var oo = { _value:1 };
    Object.defineProperty(oo,'value', {
        // value:9,
        // writable: false,
        enumerable: true,
        configurable: true,
        get: function(){
            console.log(&quot;get value...&quot;, this._value);
            return this._value;
        },
        set: function(value){
            this._value = value;
            console.log(`set value... ${this._value}`);
        }
    });

    var i = oo.value;
    oo.value += 1;
</code></pre>

<p>Vue 实现数据绑定的做法是通过 [Object.defineProperty()] 劫持数据，再通过 Publish–Subscribe Pattern 发布-订阅开发模式来管理数据变化，发布-订阅模式中 Vue 充当了发布者 ，Watcher、Computed 设置的方法则是订阅者，同时又是，Vue 劫持数据监听到数据变更时对订阅者发起调用通知数据更新。监听到 data 的数据有变化时，Vue 还会判断数据是否是原有数据对象的引用，如果不是则进入视图更新流程，用新数据渲染，这就是 Vue MVVM 原理。这个过程中 Vue 还使用了 观察者模式 Observer Pattern，和发布-订阅模式一样，都用来降低耦合度。发布订阅模式里，发布者和订阅者，不是松耦合，而是完全解耦的。相对 Watcher 来说，Vue 对计算属性 Computed 处理显得更像观察模式，即观察者通过观察计算属性中被依赖的数据来进行响应。而发布订阅模式里，除了发布者和订阅者两个角色，还有经常被忽略的经纪人 Broker，只是这个角色在代码实现上不太明显有独立模块实现。</p>
<p>计划 2019 年更新的 Vue.js 3.0 会启用新特性，将使用 ES6 的 Proxy 作为其观察者机制，取代之前使用的目前使用的 Object.defineProperty，<a href="https://mp.weixin.qq.com/s/wQf1QiMdx-As78CC3s1iYg">Vue3.0 尝鲜 defineProperty VS Proxy</a>。</p>
<p>通过 Proxy 对象可以劫持整个被代理的对象，支持 13 种劫持操作，可以实现真正的私有成员！但 Proxy 是 es6 提供的新特性，兼容性不好，也无法用 polyfill 来兼容，所以新版的 Vue 3.0 计划只支持 IE 11。Proxy 和 PHP 的魔术方法 Magic Methods 机制是类似的，这是动态语言的便利之处，如果在性能上不太消耗资源，这种便利还是可取的。参考 [Proxy 对象代理文档]。</p>
<pre><code>let obj = {};
let handler = {
    get(target, key) {
        console.log(`read ${key}`);
        return key in target ? target[key] : 3;
    },
    set(target, key, value) {
        console.log(`set ${key}=${value}`);
        target[key] = value;
    }
}
let p = new Proxy(obj, handler);
p.name = 'tom'; // set name=tom
var i = p.age; // read age
console.log("age", i); // age 3
</code></pre>
<p>还有一个 Refect 也是 Es6 的新特性，与大多数全局对象不同，Reflect 没有构造函数。你不能将其与一个 new 运算符一起使用，或者将 Reflect 对象作为一个函数来调用。Reflect 的所有属性和方法都是静态的，就像 Math 对象，参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">Reflect 文档</a>。监听数组<br />
// 如果遇到 getter，receiver 将提供给目标调用。<br />
// 如果遇到 setter，this 将提供给目标调用。</p>
<pre><code>const arr = [];
const newArr = new Proxy(arr, {
    get: function(target, key, receiver) {
        console.log(`read target`);
        return Reflect.get(target, key, receiver);
    },
    set: function(target, key, value, receiver) {
        console.log("target=", target, `target[${key}]=${value}`);
        return Reflect.set(target, key, value, receiver);
    }
});

newArr[1] = 9;
</code></pre>
<p>输出内容，六：</p>
<pre><code>read target
read target
read target
read target
read target
read target
target= [] target[1]=9 []
</code></pre>
<h1 id="vuex"><a name="user-content-vuex" href="#vuex" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Vuex 状态管理插件</h1>
<p><a href="https://vuex.vuejs.org/zh/">Vuex 官方文档</a></p>
<p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。引入 Vuex 状态管理，Vue 组件需要获取或更改状态数据时通过触发事件或动作 <code>Actions</code> 的方式告知 Vuex，在 <code>Actions</code> 中定义的方法响应需求，并将数据操作提交到 Vuex 内部集中处理，通过定义在 <code>Mutations</code> 中的数据操作方法修改保存在状态仓库 <code>store</code> 中的数据, 前缀 Mut 表示 Mutiple 多个的意思。当 State 中的数据被改变之后，Vue 会检测到数据变化并重新渲染到组件中去，组件展示更新后的数据，完成一个流程。</p>
<p>Vuex 的核心是仓库 Store，相当于是一个容器，一个 Store 实例中包含以下属性的方法：</p>
<ul>
<li>state 定义属性（状态 、数据）</li>
<li>getters 用来获取属性</li>
<li>actions 定义方法（动作）</li>
<li>commit 提交变化，修改数据的唯一方式就是显示的提交 mutations</li>
<li>mutations 定义变化，处理状态（数据）的改变</li>
<li>mapGetters 用来获取属性（数据）</li>
<li>mapActions 用来获取方法（动作）</li>
</ul>
<p>接下来写个DEMO理解 vuex，首先在vue工程目录下执行 npm 命令安装 vuex</p>
<pre><code>npm install vuex -S
</code></pre>
<p>这个命令会下载 Vuex 到工程目录的 node_modules\vuex 目录下，并修改根目录下的 package.json 配置文件，将 Vuex 添加到依赖项列表中。</p>
<p>创建 store.js 模块文件作为数据仓库，引入 Vuex 并安装到 Vue，用 state 对像保存定义属性，用它初始化创建一个 Vuex.Store 对象然后导出。以下代码使用了 ES6 的对象解构语法，和 {obj1,obj2} 这种写法一样，函数可以表达为 {count:function(state){&hellip;}} 就可以简化成 {count(state){&hellip;}} 自行补课。</p>
<pre><code>import Vue from 'vue'
import Vuex from 'vuex'
Vue.use(Vuex)

var state = {
    count:0
}

var getters = {
    count(state){
        return state.count
    }
}

const actions = {
    increment({commit,state}){
        commit('increment') 
    }
}

const mutations = {
    increment(state){
        state.count ++;
    }
}

const store = new Vuex.Store({ state, getters, actions, mutations })

export default store;
</code></pre>
<p>在入口文件 main.js 中导入上面建立的数据仓库并配置到 Vue 实例中，Vue会自动将 store 对象注入到所有子组件中，在子组件中通过 this.$store 访问该 store 数据仓库。<code>{store,el:'#app'}</code> 这写法是ES6的精简表达式，等于 <code>{store:store, el:"#app"}</code>。</p>
<pre><code>import Vue from 'vue'
import App from './App.vue'
import store from './store'

new Vue({
  store, 
  el: '#app',
  render: h =&gt; h(App)
})
</code></pre>
<p>在 app.vue 组件中引入也相应引入 <code>mapGetters</code> 和 <code>mapActions</code> 辅助函数，并用 <code>mapActions</code> 来包装数据仓库 store.js 导出的 <code>increment</code> 方法。在计算属性中调用 <code>mapGetters</code> 辅助方法，并传入一个数组，在数组中指定要获取的属性，此例子只有 <code>count</code> 这个数据属性。</p>
<pre><code>&lt;template&gt;
    &lt;div id="app"&gt;
        &lt;button @click="increment"&gt;增加&lt;/button&gt;
        &lt;button&gt;减少&lt;/button&gt;
        &lt;h1&gt;{{count}}&lt;/h1&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import {mapGetters,mapActions} from 'vuex'
export default {
    name: 'app',
    computed:mapGetters([
        'count'
    ]),
    methods:mapActions([
        'increment',
    ])
}
&lt;/script&gt;
</code></pre>
<p>在组件调用 increment 动作，就是执行数据仓库导出相应方法，然后通过 commit 将动作提交到 mutations 处理。</p>
<h1 id="cors"><a name="user-content-cors" href="#cors" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>CORS 跨域问题</h1>
<p>阮一峰老师跨域资源共享 CORS 详解： <br />
<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html">http://www.ruanyifeng.com/blog/2016/04/cors.html</a><br />
<a href="http://www.cnblogs.com/xuange306/p/6185453.html">http://www.cnblogs.com/xuange306/p/6185453.html</a></p>
<p>CORS是一个W3C标准，全称是&rdquo;跨域资源共享&rdquo;（Cross-origin resource sharing）。</p>
<p>它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了AJAX只能同源使用的限制。</p>
<p>在开发阶段可以通过禁止浏览器安全选项实现，增加启动参数，在目标后面增加如下的启动参数：</p>
<pre><code>”chrome.exe" --user-data-dir="c:\ChromeDebug" --test-type --disable-web-security
"chrome.exe" --remote-debugging-port=9222 --test-type --disable-web-security
</code></pre>
<p>表示 Chrome 会从 C:\ChromeDebug 中存取用户数据，因该目录可能为空，所以新打开的 Chrome-Debug 窗口是一个全新的 Chrome，没有书签、历史、扩展程序等内容，需要再重新安装扩展程序。</p>
<p>在服务器端直接输出 CORS 头是最直接的解决办法：</p>
<pre><code>res.header('Access-Control-Allow-Origin', 'http://localhost:5080');
// * 这个表示任意域名都可以访问，这样写不能携带cookie了。 || 'http://localhost:5080'
res.header('Access-Control-Allow-Credentials', true);
// 允许服务器端发送Cookie数据,
// 若前端设置了 axios.defaults.withCredentials = true
// 则必须相应设置 Access-Control-Allow-Credentials=true 否则会请求失败、报错
res.header('Access-Control-Allow-Headers', 'Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild');
//它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段
res.header('Access-Control-Allow-Methods', 'PUT, POST, GET, DELETE, OPTIONS');
</code></pre>
<h2 id="express-cors-server"><a name="user-content-express-cors-server" href="#express-cors-server" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Express CORS Server</h2>
<p>利用 Node.js + Express 可以快速搭建一个用于开发的代理服务器，参考代码如下，保存到 <code>cors_dev.js</code> 然后通过 node 执行它即可以运行这个用于开发的代理服务器，结果 Node 的 HTTP 模块还可以访问其它服务器的资源：</p>
<pre><code>node cors_dev.js
</code></pre>
<p>Vue CLI 3 项目默认安装好 Express，其它没有安装的模块，在项目目录下执行 npm 安装命令进行安装：</p>
<pre><code>npm install cors
npm install morgan
</code></pre>
<p>顶级 express 对象提供的 <code>Router()</code> 方法可以创建 <code>router</code> 对象。的路由中间件 <code>router</code> 可以视为 Express 的一个路由分支，可以看作一个应用程序，它的目的是中间件和路由的分离的实例。和 Express 应用一样，可以通过 <code>get()</code>、<code>post()</code> 等等方法设置路由及响应方法。</p>
<p>Express 默认使用 jade 模板，可以配置让其支持使用 ejs 或 html 模板，渲染模板使用 <code>render()</code> 方法，模板文件存放于 <code>views</code> 目录下。Express 实例的 <code>set()</code> 方法有一项是 <code>view engine</code>，在没有指定文件模板格式时，设置默认使用的引擎插件。</p>
<p>当一个路由匹配命中后，就会执行相应的回调函数来响应浏览器。<code>all("*")</code> 表示匹配所有可能，但它定义在最后面，只响应前面那些路由没有匹配时的情况。</p>
<p>输出 CORS 头信息可以直接使用 Express 的 <code>header()</code> 方法，也可以在路由方法中直接使用 <code>cors()</code> 方法，如例中的 <code>/hello</code> 和 <code>/vue/config</code> 两个路由地址。使用方法参考官方文档 <a href="http://www.expressjs.com.cn/4x/api.html#app.all">Express.js API</a> &amp; <a href="https://www.npmjs.com/package/cors">Node cors package</a>。</p>
<pre><code>var express = require("express");
var cors = require("cors");
var path = require("path");
var logger = require("morgan");
var ejs = require('ejs');
var https = require('https');
var http = require('http'); 
// var favicon = require("favicon");
// var cookieParser = require("cookie-parser");
// var bodyParser = require("body-parser");

var router = express.Router();
router.get('/', (req, res, next)=&gt;{
  res.render('index.html', {title:"Express Web Server。", BASE_URL:"/"});
  res.send("Express Web: GET /");
});
router.get('/vue/config', cors(), (req, res, next)=&gt;{

  res.json({state:"ok", config:"TODO..."});
});
router.post('/', (req, res, next)=&gt;{
  res.json({title:"Express Web Server!"});
});
// module.exports = router

var app = express();
app.engine('html', ejs.__express);
app.set('view engine', 'html');
app.use("/", router);
app.get('/hello', cors(), (req, res) =&gt; res.send('Hello World!'));
app.use(logger("common")); // combined:Standard Apache combined log output. 
app.use(cors({
    origin:['http://localhost:80','*'],
    methods:['GET','POST'],
    alloweHeaders: ['Access-Control-Allow-Origin', 'Conten-Type', 'Authorization']
}));

app.all("*", function (req, res, next) {
  res.header("Access-Control-Allow-Credentials", "true");
  res.header("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept");
  res.header("Access-Control-Allow-Origin", "*");
  res.header("Access-Control-Allow-Methods", "PUT,POST,GET,DELETE,OPTIONS");
  res.send('Express...');
  next();
});

app.listen(3000, () =&gt; console.log('Example app listening on port 3000!'))
</code></pre>
<p>如果系统安装了 curl 工具，可以直接使用命令查看 CORS 头信息是否已经设置好：</p>
<pre><code>curl -v -I -H "Origin: https://github.com" http://localhost:3000/
</code></pre>
<h1 id="basic-syntax"><a name="user-content-basic-syntax" href="#basic-syntax" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Basic Syntax 基本模板语法</h1>
<h2 id="_2"><a name="user-content-_2" href="#_2" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>{{&hellip;}} 文本插值</h2>
<p>数据绑定最常见的形式就是使用双大括号文本插值</p>
<pre><code>template: ` &lt;div&gt;{{ count }}&lt;/div&gt; `
</code></pre>
<h2 id="v-bind"><a name="user-content-v-bind" href="#v-bind" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>v-bind</h2>
<p>HTML 属性中的值应使用 v-bind 指令，模板变量不用双花括号。下为判断 cancss 的值，如果为 true 使用 class1 类的样式，否则不使用</p>
<pre><code>&lt;div v-bind:class="{'class1': cancss}"&gt; cancss &lt;/div&gt;
&lt;div v-bind:class="[activeClass, errorClass]"&gt;可以是数组 &lt;/div&gt;
&lt;div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }"&gt; inline-style 内联样式 &lt;/div&gt;
&lt;div v-bind:style="styleObject"&gt; 多个样式对象 styleObject 类似于 { color: 'green' } &lt;/div&gt;
&lt;div v-bind:style="[baseStyles, overridingStyles]"&gt; 多个样式对象 &lt;/div&gt;
</code></pre>
<p>当 v-bind:style 使用需要特定前缀的 CSS 属性时，如 transform ，Vue.js 会自动侦测并添加相应的前缀。</p>
<pre><code>&lt;img v-bind:src="imagepath" /&gt;
&lt;a v-bind:href="url"&gt; demo &lt;/a&gt;
&lt;a :href="url"&gt; 缩写语法 &lt;/a&gt;
</code></pre>
<h2 id="v-html"><a name="user-content-v-html" href="#v-html" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>v-html</h2>
<p><code>v-html</code> 指令用于输出 html 代码，假设 <code>rawHtml</code> 包含HTML字符串。</p>
<pre><code>&lt;div v-html="rawHtml"&gt;&lt;/div&gt;
</code></pre>
<h2 id="v-model"><a name="user-content-v-model" href="#v-model" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>v-model</h2>
<p>在 input 输入框中我们可以使用 v-model 指令来实现双向数据绑定</p>
<pre><code>&lt;input type="checkbox" v-model="isWeixin" &gt;
</code></pre>
<p><code>v-model</code> 其实就是 <code>v-bind:checked</code> 的语法糖，参考官方文档。代码里面混用 <code>v-bind:checked="xxx"</code>和 <code>v-model="xxx"</code> 是错误的。</p>
<h2 id="vuejs-javascript"><a name="user-content-vuejs-javascript" href="#vuejs-javascript" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Vue.js 都提供了完全的 JavaScript 表达式支持。</h2>
<pre><code>&lt;div id="app"&gt;
    {{5+5}}&lt;br&gt;
    {{ ok ? 'YES' : 'NO' }}&lt;br&gt;
    {{ message.split('').reverse().join('') }}
    &lt;div v-bind:id="'list-' + id"&gt;demo&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h2 id="v-if-v-else-if"><a name="user-content-v-if-v-else-if" href="#v-if-v-else-if" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>v-if v-else-if 条件判断</h2>
<pre><code>&lt;p v-if="seen"&gt; 看到我了 &lt;/p&gt;
&lt;p v-else-if="watch"&gt; 看到她了 &lt;/p&gt;
&lt;p v-else&gt; 看到它了 &lt;/p&gt;
</code></pre>
<p>注意条件中的元素要前后紧接，不能被其它元素隔开。</p>
<h2 id="v-show"><a name="user-content-v-show" href="#v-show" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>v-show</h2>
<p>指令根据条件展示元素，HTML一直在页面存在，这点与 v-if 有区别：</p>
<pre><code>&lt;h1 v-show="isGreeting"&gt;Hello!&lt;/h1&gt;
</code></pre>
<h2 id="v-for"><a name="user-content-v-for" href="#v-for" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>v-for 循环指令</h2>
<p>有两种语法格式。 item in items 形式语法，items 是源数据数组或迭代对象甚至是迭代整数，并且 item 是数组元素迭代的别名。</p>
<pre><code>&lt;ol&gt; &lt;li v-for="i in 10"&gt; {{ i }} &lt;/li&gt; &lt;/ol&gt;
&lt;ol&gt; &lt;li v-for="item in items"&gt; {{ item.name }} &lt;/li&gt; &lt;/ol&gt;
&lt;ol&gt; &lt;li v-for="(value, index) in items"&gt; {{ index + "-" +value.name }} &lt;/li&gt; &lt;/ol&gt;
&lt;ul&gt; &lt;li v-for="(value, key, [index]) in object"&gt; {{ key }} : {{ value }} &lt;/li&gt; &lt;/ul&gt;
&lt;div v-for="item in items"&gt;{{ $index }} - {{ item.message }}&lt;/div&gt;

&lt;a v-for="(item,index) in items" v-on:click="onclick(event,index)"&gt;{{ index }}{{ item.text }} vue 2.0&lt;/a&gt;
&lt;a v-for="(index,item) in items" data-index="{{index}}" v-on:click="onclick(event, $index)"&gt;{{ item.text }} vue 1.0&lt;/a&gt;

onclick:function(event){
    event.preventDefault();
    let target = event.target
    console.log(target.getAttribute("data-index"));
    document.getElementById('index').value = target.getAttribute("data-index");
}
</code></pre>
<h2 id="v-on"><a name="user-content-v-on" href="#v-on" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>v-on 事件绑定</h2>
<p>监听事件，并对用户的输入进行响应。</p>
<pre><code>&lt;button v-on:click="doClick"&gt;Click Me&lt;/button&gt;
&lt;a @click="doClick"&gt;缩写语法&lt;/a&gt;
&lt;div @click.stop="doClick()"&gt;阻止冒泡方法&lt;/div&gt;
&lt;div @click="doClick($event)"&gt;事件对象引用&lt;/div&gt;
&lt;div @contextmenu.prevent="show2()"&gt;右键&lt;/div&gt;
&lt;div @contextmenu="show2($event)"&gt;右键&lt;/div&gt;
</code></pre>
<h2 id="_3"><a name="user-content-_3" href="#_3" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>后缀修饰符</h2>
<p>修饰符是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如 .prevent 等效 event.preventDefault()：</p>
<pre><code>&lt;form v-on:submit.prevent="onSubmit"&gt;&lt;/form&gt;

&lt;!-- 阻止单击事件继续传播 --&gt;
&lt;a v-on:click.stop="doThis"&gt;&lt;/a&gt;

self  只点自己身上才运行
&lt;div @click="parent"&gt;parent
    &lt;div @click.self="child"&gt;child
        &lt;div @click="grandson"&gt;grandson&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;!-- 提交事件不再重载页面 --&gt;
&lt;form v-on:submit.prevent="onSubmit"&gt;&lt;/form&gt;

&lt;!-- 修饰符可以串联 --&gt;
&lt;a v-on:click.stop.prevent="doThat"&gt;&lt;/a&gt;

&lt;!-- 只有修饰符 --&gt;
&lt;form v-on:submit.prevent&gt;&lt;/form&gt;

&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;
&lt;!-- 即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理 --&gt;
&lt;div v-on:click.capture="doThis"&gt;...&lt;/div&gt;

&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;
&lt;!-- 即事件不是从内部元素触发的 --&gt;
&lt;div v-on:click.self="doThat"&gt;...&lt;/div&gt;

&lt;!-- 点击事件将只会触发一次 --&gt;
&lt;a v-on:click.once="doThis"&gt;&lt;/a&gt;
不像其它只能对原生的 DOM 事件起作用的修饰符，.once 修饰符还能被用到自定义的组件事件上。如果你还没有阅读关于组件的文档，现在大可不必担心。

&lt;!-- the scroll event will not cancel the default scroll behavior --&gt;
&lt;div v-on:scroll.passive="onScroll"&gt;...&lt;/div&gt;
Vue 为这些修饰符额外提供了 .passive 修饰符来提升移动端的性能。举个例子，在滚动的时候，浏览器会在整个事件处理完毕之后再触发滚动，因为浏览器并不知道这个事件是否在其处理函数中被调用了 event.preventDefault()。.passive 修饰符用来进一步告诉浏览器这个事件的默认行为不会被取消。

不要把 .passive 和 .prevent 一起使用。被动处理函数无法阻止默认的事件行为。

native修饰符用在组件的根元素上监听一个原生事件，在普通的HTML标签监听一个事件.native 修饰符是不会起作用的。如router-link会阻止click事件，你可以试试只用click不用native,事件是不会触发的。router-link上添加事件的话需要@click.native。
</code></pre>
<h2 id="filters-pipe"><a name="user-content-filters-pipe" href="#filters-pipe" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Filters &amp; Pipe</h2>
<p>Vue.js 允许你自定义过滤器，被用作一些常见的文本格式化。由&rdquo;管道符&rdquo;指示, 过滤器函数接受表达式的值作为输入，格式如下：</p>
<pre><code>&lt;!-- 在两个大括号中 --&gt;
{{ message | capitalize }}

&lt;!-- 在 v-bind 指令中 --&gt;
&lt;div v-bind:id="rawId | formatId"&gt;&lt;/div&gt;

过滤器可以串联：
{{ message | filterA | filterB }}

过滤器是函数可以接受参数，这里 message 是第一个参数，arg2 是表达式的值将被求值然后传给过滤器作为第三个参数。
{{ message | filterA('arg1', arg2) }}
</code></pre>
<h1 id="_4"><a name="user-content-_4" href="#_4" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>表单选择项状态绑定</h1>
<p><a href="http://www.runoob.com/vue2/vue-forms.html">http://www.runoob.com/vue2/vue-forms.html</a></p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;title&gt;Vue 表单测试实例&lt;/title&gt;
        &lt;script src="https://cdn.staticfile.org/vue/2.2.2/vue.min.js"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id="app" class="panel"&gt;

            &lt;div class="well"&gt;
                &lt;p&gt;单选框：&lt;/p&gt;
                &lt;input type="radio" value="ABC" name="group" v-model="radio"&gt;
                &lt;input type="radio" value="XYZ" name="group" v-model="radio"&gt;
                &lt;label for="checkbox"&gt;{{ radio }}&lt;/label&gt;
            &lt;/div&gt;

            &lt;div class="well"&gt;
                &lt;p&gt;单个复选框：&lt;/p&gt;
                &lt;input type="checkbox" value="true" id="checkbox1" v-model="listA"&gt;
                &lt;label for="checkbox1"&gt;{{ listA }}&lt;/label&gt;
                &lt;input type="checkbox" value="false" id="checkbox2" v-model="listB"&gt;
                &lt;label for="checkbox2"&gt;{{ listB }}&lt;/label&gt;
            &lt;/div&gt;

            &lt;div class="well"&gt;
                &lt;p&gt;多个复选框：&lt;/p&gt;
                &lt;input type="checkbox" id="vue" value="Vue" v-model="checkedNames"&gt;
                &lt;label for="vue"&gt;vue&lt;/label&gt;
                &lt;input type="checkbox" id="bootstrap" value="Bootstrap" v-model="checkedNames"&gt;
                &lt;label for="bootstrap"&gt;Bootstrap&lt;/label&gt;
                &lt;p&gt;选择的值为: {{ checkedNames }}&lt;/p&gt;
            &lt;/div&gt;

            &lt;div class="well"&gt;
                &lt;select v-model="selected" name="strawberry"&gt;
                &lt;option value=""&gt;单选选择&lt;/option&gt;
                &lt;option value="vue"&gt;vue&lt;/option&gt;
                &lt;option value="bootstrap"&gt;bootstrap&lt;/option&gt;
                &lt;/select&gt;
                &lt;p&gt;选择的是: {{selected}}&lt;/p&gt;
            &lt;/div&gt;

            &lt;div class="well"&gt;
                &lt;select multiple v-model="multiple" name="strawberry"&gt;
                &lt;option value=""&gt;多选列表&lt;/option&gt;
                &lt;option value="vue"&gt;vue&lt;/option&gt;
                &lt;option value="bootstrap"&gt;bootstrap&lt;/option&gt;
                &lt;/select&gt;
                &lt;p&gt;选择的是: {{multiple}}&lt;/p&gt;
            &lt;/div&gt;

        &lt;/div&gt;
    &lt;/div&gt;
    &lt;script&gt;
    new Vue({
        el: '#app',
        data: {
            radio : "XYZ",
            listA : "true",
            listB : "true",
            selected : '',
            multiple : ['vue','bootstrap'],
            checkedNames: []
        }
    })
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h1 id="babel"><a name="user-content-babel" href="#babel" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>babel 工具使用</h1>
<p>IE天生天然残缺，像反引号/模板字符串/ES6对象解构等待支持不到位，如果要vue兼容IE，这些特异功能就不能用了。浏览器的更新速度跟不上脚本发展的速度，使用新脚本特性的需求又强烈，那么Babel就产生了，它可以让你在落后的浏览器使用新的语言特性。</p>
<p>Babel 是一个 JavaScript 语法解析器，Babel is a JavaScript compiler。将 ECMAScript 6 代码转换成浏览器可识别的 ECMAScript 5 代码，这也正是 Babel 的前身 6to5 名字的由来。随着 Babel 不断的发展，现在它已经不再仅仅为了 6to5 而存在。本文旨在跟大家聊一聊如今的 Babel 是怎样处理我们的代码，以及我们还能用 Babel 做些什么。要使用 Babel 的功能，最直接的办法就是引入它的 core-js-bundle：</p>
<pre><code>&lt;script type="text/javascript" src="//unpkg.com/core-js-bundle@3.0.0-beta.3/minified.js"&gt;&lt;/script&gt;
</code></pre>
<p>由于 Babel 默认只转换转各种 ES2015 语法，而不转换新的 API，比如 Promise，以及 Object.assign、Array.from 这些新方法，这时我们需要提供一些 ployfill 来模拟出这样一个提供原生支持功能的浏览器环境。</p>
<p>主要有两种方式：babel-runtime 和 babel-polyfill。</p>
<p>babel-runtime 的作用是模拟 ES2015 环境，包含各种分散的 polyfill 模块，我们可以在自己的模块里单独引入，比如 promise：</p>
<pre><code>import 'babel-runtime/core-js/promise'
</code></pre>
<p>它们不会在全局环境添加未实现的方法，只是这样手动引用每个 polyfill 会非常低效，我们可以借助 Runtime transform 插件来自动化处理这一切。</p>
<p>而 babel-polyfill 是针对全局环境的，引入它浏览器就好像具备了规范里定义的完整的特性，一旦引入，就会跑一个 babel-polyfill 实例。</p>
<ul>
<li>
<p>以 CLI 方式使用 Babel，安装cli工具，及使用方法：</p>
<p>npm install &ndash;save-dev babel-cli<br />
babel src -d lib</p>
</li>
</ul>
<p>然后是安装转译器和创建配置文件 .babelrc，只有在配置文件设置了转译器，babel 才对代码进行转换:</p>
<pre><code>npm install babel-preset-env --save-dev

// enable babel-preset-env in .babelrc configuration
{
  "presets": ["env"]
}
</code></pre>
<p>babel-preset-es2015 这样的配置可以退下了：</p>
<pre><code>{
    "presets": [
        ["es2015", {"modules": false }]
    ]
}
</code></pre>
<p>babel命令行工具（babel-cli）跟babel转译器(presets暂且用这译法)是两个不同的东西，命令行工具并不具有转译代码的功能，只是为了在命令行中使用babel。要转码必须安装转译器，比如babel-preset-env转译器或者babel-preset-react转译器。要转译的时候，还要在.babelrc文件或者命令行中配置这些转译器(presets)选项。</p>
<p>Babel 的官网宣布 ES2015 / ES2016/ ES2017 等等 ES20xx 时代的 presets 通通被废弃（deprecated），取而代之的是 babel-preset-env，并且承诺它将成为“未来不会过时的（future-proof）”解决方案。</p>
<p>.babelrc不是必须的，我们在.babelrc中配置的选项都可以通过命令行添加，比如在命令行执行 babel src -d lib &ndash;presets=env 等价于在.babelrc中配置 &ldquo;presets&rdquo;:[&ldquo;env&rdquo;]。当然.babelrc要明显方便很多。</p>
<p>babel在转译代码的过程中会自动读取当前目录.babelrc配置文件，如果当前目录没有的话就遍历整个目录树去寻找，直到找到.babelrc文件或者含有&rdquo;babel&rdquo;字段的package.json文件，然后使用这些配置选项来转译代码。</p>
<p>关于.babelrc的注意点如下。</p>
<p>1、如果没有.babelrc文件，或者没有在其他文件中设置过babel的presets的配置选型，并且命令行中也没有配置&ndash;presets，那么代码是不会转译的。原es6代码什么样，转译后的代码还是什么样。</p>
<p>2、如果你的.babelrc或者你的命令行使用了你没有安装的转译器（presets），代码就会报错</p>
<p>3、但.babelrc中的配置跟你在命令行中使用的配置冲突的时候，以.babelrc中的配置为准</p>
<ul>
<li>
<p>搭配 webpack 编译系统使用，首先执行安装命令，转译器，一并创建配置文件 .babelrc</p>
<p>npm install &ndash;save-dev babel-loader babel-core<br />
npm install babel-preset-env &ndash;save-dev</p>
</li>
</ul>
<p>如果项目里只有 babel-preset-es2015，那就赶紧装上 babel-preset-env，这个配置不好在IE9上会有 Promise”未定义&rdquo;。然后通过配置文件方式或 loader 方式使用：</p>
<pre><code>// Via config
module: {
    rules: [
        { test: /\.js$/, exclude: /node_modules/, loader: "babel-loader" }
    ]
}

// Via loader
var Person = require("babel!./Person.js").default;
new Person();
</code></pre>
<ul>
<li>
<p>或者使用 babel-polyfill:</p>
<p>npm install &ndash;save-dev babel-polyfill</p>
</li>
</ul>
<p>如果使用vue-cli项目，在webpack.config.js中添加：</p>
<pre><code>require('babel-polyfill');

entry: {
    app: ['babel-polyfill', './src/main.js']
},
</code></pre>
<p>参考文档： <br />
<a href="https://babeljs.io/setup#installation">https://babeljs.io/setup#installation</a><br />
<a href="https://babeljs.io/docs/en/usage">https://babeljs.io/docs/en/usage</a><br />
<a href="http://www.ruanyifeng.com/blog/2016/01/babel.html">http://www.ruanyifeng.com/blog/2016/01/babel.html</a></p>
<p>Vue 全家桶是 Vue 和 Vue-router，Vuex，Axios 组合的统称，这四个组合在一起可以算是一个全功能前端开发配置，VueRouter 做SPA单页面应用，Vuex 做数据仓库状态管理，Axios 做 Ajax 应用。</p>
<p>ivew则是基于vue的ui组件库，类似ui组件库还有 elment, mint-ui等。</p>
<p>iview 快速上手： <a href="https://www.iviewui.com/docs/guide/start#AXYY">https://www.iviewui.com/docs/guide/start#AXYY</a></p>
<h1 id="css-chrome-devtools"><a name="user-content-css-chrome-devtools" href="#css-chrome-devtools" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>CSS热更新 双向修改 Chrome DevTools</h1>
<p>Chrome 开发都工具提供了一个非常实用有功能，通过映射将页面的样式关联到本地的一个样式表文件，下面是设置步骤</p>
<p>第一步是设置工作区</p>
<pre><code>+ 打开chrome开发者工具(F12)
+ 选择 source 栏，在左栏任意位置右键，点击'Add folder to workspace'
+ 选择一个本地工作目录，里面应该含有 css 样式文件
+ 在弹出权限提示框中，点击'允许'即可
+ Sources 栏会新增添加进来的文件夹，则说明工作区配置好了
</code></pre>
<p>第二步是设置样式文件映</p>
<pre><code>+ 在 Sources 栏的目录树中选择你想进行映射的css文件，右键菜单选择'Map to file system resource..
+ 在弹出框中选择工作区中相应的css文件
+ 选择完成后可以看到，原先在服务器中的文件被移到了我们的工作区文件夹中
</code></pre>
<p>第三步是测试实时更新效果</p>
<p>配置好了工作区和文件映射，来看看最终的效果吧</p>
<pre><code>+ 我们先修改本地css中的内容，在这里，我们将p标签的颜色属性改为绿色，并保存查看浏览器更新。
+ 接着我们在Elemnts栏中，手动更改h1标签的font-size属性
+ 回到工作区的文件中，可以看到文件也被实时更新了，再也不用按F5刷新了！！！
</code></pre>
<p>以下几点注意事项摘自chrome开发者工具帮助手册<br />
1、只有 Elements 面板中的样式更改会保留；对 DOM 的更改不会保留<br />
2、仅可以保存在外部 CSS 文件中定义的样式。对 element.style 或内嵌样式的更改不会保留。<br />
3、如果您有映射到本地文件的 CSS 资源，在 Elements面板中进行的样式更改无需显式保存即会立即保留 - Ctrl + S 或者 Cmd + S (Mac)<br />
4、如果您正在从远程服务器映射文件，Chrome 会从远程服务器重新加载页面。您的更改仍将保存到磁盘，并且如果您在工作区中继续编辑，这些更改将被重新应用<br />
5、您必须在浏览器中使用映射文件的完整路径。要查看暂存版本，您的索引文件在网址中必须包含 .html</p>
<h1 id="vue-devtools"><a name="user-content-vue-devtools" href="#vue-devtools" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>浏览器上使用 Vue Devtools 工具</h1>
<p>Vue.js devtools是基于google chrome浏览器的一款调试vue.js应用的开发者浏览器扩展，可以在浏览器开发者工具下调试代码。</p>
<p>可以通过 github 下载devtools源码，用 npm 编译安装，地址：<a href="https://github.com/vuejs/vue-devtools">https://github.com/vuejs/vue-devtools</a>。<br />
也可就直接下载编译版本，在任意空目录下执行 npm 获取 devtools 插件：</p>
<pre><code>npm i vue-devtools
</code></pre>
<p>以上命令会下载插件到 node_modules\vue-devtools\vender 目录中，其中 manifest.json 就是 Chrome &amp; Firefox 安装插件时需要用到的配置文件。手上在用的UC也是可以安装的，打开扩展面板，开启开发者模式，就可以装入已解压的插件。</p>
<p>常见问题</p>
<ul>
<li>
<p>Vue.js not detected</p>
</li>
<li>
<p>Vue.js is detected on this page. Devtools inspection is not available because it&rsquo;s in production mode or explicitly disabled by the author.<br />
若在浏览器中打开控制台刷新之后还是没有vue，可以检查是否使用的是压缩版本的vue.min.js，默认为生产环境的，这种情况是默认关闭调试的。</p>
<p><script src="https://unpkg.com/vue/dist/vue.js"></script></p>
</li>
<li>
<p>Vue.js is detected on this page. Open DevTools and look for the Vue panel. <br />
重启浏览器就可以在开发工具面板中找到vue</p>
</li>
</ul>
<p>或者在代码的主文件中配置vue的环境：</p>
<pre><code>Vue.config.devtools = true
</code></pre>
<p>尝试在配置文件plugin中导出:</p>
<pre><code>new webpack.DefinePlugin({
    'process.env': { 'NODE_ENV':'"development"'}
}),
</code></pre>
<p>可以选择把后台常驻模式打开，persistent 设置为 true</p>
<pre><code>"background": {
    "scripts": [
      "build/background.js"
    ],
    "persistent": false
}
</code></pre>
<h1 id="webpack"><a name="user-content-webpack" href="#webpack" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>webpack基础 优化打包发布 去掉#号 页面空白问题</h1>
<ul>
<li>webpack 基础<br />
<a href="https://github.com/ruanyf/webpack-demos">https://github.com/ruanyf/webpack-demos</a><br />
<a href="https://webpack.js.org/concepts/">https://webpack.js.org/concepts/</a><br />
<a href="http://www.ruanyifeng.com/blog/2018/03/node-debugger.html">http://www.ruanyifeng.com/blog/2018/03/node-debugger.html</a><br />
<a href="http://www.ruanyifeng.com/blog/2016/09/react-technology-stack.html">http://www.ruanyifeng.com/blog/2016/09/react-technology-stack.html</a></li>
</ul>
<p>webpack总得来说是一个js打包工具，它的思想是模块化思想，不管你是js，css，还是scss，less，还是jsx，webpack统统都能打包。在webpack看来一切都是模块！有合适的loaders，它们都可以被当做模块被处理。</p>
<ul>
<li>webpack的基本概了解</li>
</ul>
<p>Entry    即打包后运行入口，默认是 ./src/index.js，可以在配置文件中修改。<br />
Output   出口打包文件即打包生成的文件，默认在 ./dist/main.js，可以通过配置修改。<br />
Mode     模式设置，基本上有 development, production, none 几种模式。根据不同的模式使用不同的配置文件来优化开发/发布。</p>
<p>Loaders  加载器， webpack 只认 JavaScript 和 JSON，通过 Loaders 可以让 webpack 以模块的形式加载其它资源，加载器负责资源内容的转换。最简单的加载器配置只需要 test 和 use 两项。</p>
<pre><code>module: {
    rules: [
        { test: /\.txt$/, use: 'raw-loader' }
    ]
}
</code></pre>
<p>上面这个规则配置告诉 webpack 在打包时，遇到 require()/import 中的 txt 文本文件要使用 raw-loader 处理。</p>
<p>除了加载器，webpack 还提供了插件接口，插件是 webpack 的基本骨架。以 html-webpack-plugin 这个插件为例，首先通过 npm 安装它，需要使用时通过 require 引入。</p>
<pre><code>const HtmlWebpackPlugin = require('html-webpack-plugin'); //installed via npm
const webpack = require('webpack'); //to access built-in plugins

module.exports = {
    module: {
        rules: [
            { test: /\.txt$/, use: 'raw-loader' }
        ]
    },
    plugins: [
        new HtmlWebpackPlugin({template: './src/index.html'})
    ]
};
</code></pre>
<p>In the example above, the html-webpack-plugin generates an HTML file for your application by injecting automatically all your generated bundles.</p>
<p>There are many plugins that webpack provides out of the box! Check out the list of plugins.<br />
Using plugins in your webpack config is straightforward - however, there are many use cases that are worth further exploration. Learn more about them here.</p>
<p>浏览器兼容，webpack 支持基于 ES5 的浏览器 (IE8 and below are not supported)，这是因为 webpack 使用 Promise 来实现 import() require.ensure()。如果要兼容旧浏览器，可以考虑使用 polyfill。</p>
<p>webpack项目文件有三大组成，package.json 是项目依赖包，webpack.config.js 是打包配置文件，脚本文件，VUE项目包含 server.js 自带的服务器用来在本机进行调试。package.json 也是 npm 的配置信息文件，建议了解一些 npm 脚本基础。如 scripts 中配置的是命令，通过 npm run 执行脚本命令时，会新建一个 shell 来执行这里配置的命令，所以只要系统认识的命令都可以在这配置。另外 npm 提供了 pre &amp; post 钩子机制，如 npm run build 执行时，简写成 npm build，它可以按顺序调用以下三个脚本：</p>
<pre><code>"prebuild": "echo I run before the build script",
"build": "cross-env NODE_ENV=production webpack",
"postbuild": "echo I run after the build script"
</code></pre>
<p>使用钩子可以用来做一些前期或后期动作，如清理工作，像 clean-webpack-plugin 这种插件就是一行脚本配置的事。清理脚本也可以这样写脚本：</p>
<pre><code>"clean": "rimraf ./dist &amp;&amp; mkdir dist",
"prebuild": "npm run clean",
"build": "cross-env NODE_ENV=production webpack"
</code></pre>
<p>如果脚本中需要执行多组命令，&amp; 可以用来连接命令，写成 a &amp; b，它会按前后顺序运行命令 a 和 b。而 a &amp;&amp; b 则会在 a 命令成功后才执行 b 命令。npm 脚本有一个非常强大的功能，就是可以使用 npm 的内部变量。 通过环境变量process.env对象，拿到package.json配置信息，再通过npm_package_前缀可以获取配置文件内的配置项，如脚本中读取 name &amp; version 等信息：</p>
<pre><code>console.log(process.env.npm_package_name);
console.log(process.env.npm_package_version);
console.log(process.env.npm_package_scripts_build);
</code></pre>
<p>以下是常用脚本，参考：<br />
<a href="http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html">http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html</a></p>
<pre><code>"prebuild": "del /Q dist\\*",
"clean": "rimraf dist/*", // 删除目录
"clean": "rimraf dist/*", // 删除目录
"serve": "http-server -p 9090 dist/", // 本地搭建一个 HTTP 服务
"open:dev": "opener http://localhost:9090", // 打开浏览器
"livereload": "live-reload --port 9091 dist/", // 实时刷新
"build:html": "jade index.jade &gt; dist/index.html", // 构建 HTML 文件
"watch:css": "watch 'npm run build:css' assets/styles/", // 只要 CSS 文件有变动，就重新执行构建
"watch:html": "watch 'npm run build:html' assets/html", // 只要 HTML 文件有变动，就重新执行构建
"deploy:prod": "s3-cli sync ./dist/ s3://example-com/prod-site/", // 部署到 Amazon S3
"build:favicon": "node scripts/favicon.js", // 构建 favicon
</code></pre>
<p>webpack提供两个工具处理样式表，css-loader 和 style-loader，二者处理的任务不同，css-loader使你能够使用类似@import 和 url(&hellip;)的方法实现require()的功能,style-loader将所有的计算后的样式加入页面中，二者组合在一起使你能够把样式表嵌入webpack打包后的JS文件中，安装命令：</p>
<pre><code>npm install --save-dev style-loader css-loader
</code></pre>
<p>CSS modules 的技术就意在把JS的模块化思想带入CSS中来，通过CSS模块，所有的类名，动画名默认都只作用于当前模块。Webpack从一开始就对CSS模块化提供了支持，在CSS loader中进行配置后，你所需要做的一切就是把”modules“传递都所需要的地方，然后就可以直接把CSS的类名传递到组件的代码中，且这样做只对当前组件有效，不必担心在不同的模块中具有相同的类名可能会造成的问题。</p>
<p>插件（Plugins）是用来拓展Webpack功能的，它们会在整个构建过程中生效，执行相关的任务。Loaders和Plugins常常被弄混，但是他们其实是完全不同的东西，可以这么来说，loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程其作用。Webpack有很多内置插件，同时也有很多第三方插件，可以让我们完成更加丰富的功能。</p>
<p>Hot Module Replacement（HMR）也是webpack里很有用的一个插件，它允许你在修改组件代码后，自动刷新实时预览修改后的效果，这个特性在开发过程中作用非常巨大。在新版本中，这个插件已经内置了，通过 webpack-dev-server 指定 hot 参数就可以使用：</p>
<pre><code>webpack-dev-server --content-base ./ --open --inline --hot ...
</code></pre>
<p>在 Webpack 4 中，不再强制要求指定 entry 和 output 路径。webpack 4 会默认 entry 为 ./src，output 为 ./dist。</p>
<p>webpack 的配置 webpack.base.config.js 的入口项，把该添加的入口模块都添加上。对于多页应用存在多个入口，entry可以是字符串（单入口），可以是数组（多入口），但为了后续发展，请务必使用object，因为object中的key在webpack里相当于此入口的name，既可以后续用来拼生成文件的路径，也可以用来作为此入口的唯一标识。</p>
<pre><code>entry: {
    index: './src/index',
    main: './src/main',
    vendors: './src/vendors'
},
</code></pre>
<p>webpack 的输出 output 参数告诉webpack以什么方式来生成输出文件。与entry不同，output相当于一套规则，所有的入口产生的输出文件都必须使用这一套规则，不能针对某一个特定的入口来制定output规则。输出项中用<a href="https://vuejs.org/v2/api/#name">name</a>来引用entry每一项中的key，用以批量指定生成后文件的名称。[hash]引用本次编译的一个hash版本，[chunkhash] 引用的是当前chunk的一个hash版本。也就是说，在同一次编译中，每一个chunk的hash都是不一样的；而在两次编译中，如果某个chunk根本没有发生变化，那么该chunk的hash也就不会发生变化。</p>
<p>相对SAP的单面入口，多页应用的每个模块可以对应一个页面，由于多个页面对应多个输出文件，多页应用需要在每个页面中引入公共的 JavaScript 文件以及其自身的 JavaScript 文件。这个引用如果是 CSS 文件，则可以由 extract-text-webpack-plugin 这个插件自动提取并插入到 HTML 页面，对于 HTML 页面中引入 JavaScript 文件则需要使用 html-webpack-plugin 这个插件。以下就是一个页面的配置，多个页面则可以将页面记录在数组中，然后通过脚本枚举生成相应的配置，当然在数量不多的情况下，复制几份配置也是可行的：</p>
<pre><code>new HtmlWebpackPlugin({
    filename: '../index.html',
    template: './src/template/index.ejs',
    inject: false
})

['index','home','login'].forEach((page) =&gt; {
    const htmlPlugin = new HTMLWebpackPlugin({
        filename: `${page}.html`,
        template: path.resolve(__dirname, `../src/html/${page}.html`),
        chunks: [page, 'commons'],
    });
    HTMLPlugins.push(htmlPlugin);
    Entries[page] = path.resolve(__dirname, `../src/js/${page}.js`);
})
</code></pre>
<p>模板的配置参考插件文档，这里稍作引导，原有一个模板内容如下：</p>
<pre><code>&lt;link rel="stylesheet" href="&lt;%= htmlWebpackPlugin.files.css[0] %&gt;"&gt;
&lt;script type="text/javascript" src="&lt;%= htmlWebpackPlugin.files.js[0] %&gt;"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="&lt;%= htmlWebpackPlugin.files.js[1] %&gt;"&gt;&lt;/script&gt;
</code></pre>
<p>webpack 编译时，会产生输出文件，插件可以获取到相应的文件列表，通过输出列表里的文件信息到模板就可以实现引入脚本文件到页面。js[0] 代表的是 vendor.js 共公部分，js[1] 代表的是 main.js 即入口模块，这里有路由配置信息。js[2], js[3] 则会分别代表两个页面模块生成的输出文件，新建一个模板并且把模板名字设置到插件配置项里就可以完成页面的生成动作。</p>
<pre><code>&lt;link rel="stylesheet" href="&lt;%= htmlWebpackPlugin.files.css[0] %&gt;"&gt;
&lt;script type="text/javascript" src="&lt;%= htmlWebpackPlugin.files.js[0] %&gt;"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="&lt;%= htmlWebpackPlugin.files.js[1] %&gt;"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="&lt;%= htmlWebpackPlugin.files.js[2] %&gt;"&gt;&lt;/script&gt;

new HtmlWebpackPlugin({
    filename: '../TabPane.html',
    template: './src/template/TabPane.ejs',
    inject: false
})
</code></pre>
<ul>
<li>页面空白问题</li>
</ul>
<p>新手打包vue项目，并行编译结果出现页面空白问题。一般是因为配置不正确导致的，：</p>
<pre><code>"main": "index.js",
</code></pre>
<p>router路由配置文件夹下index.js的设置，极有可能是没有匹配的路由项导致页面无内容。仔细检查各个路由配置项，需要 VurRouter 的基础自行补课</p>
<pre><code>// mode:'hash' 
mode: 'history',//去掉#，
base: '/app/',  //这个配置也很重要，否则会出现页面空白情况
scrollBehavior: () =&gt; ({ y: 0 }),
</code></pre>
<ul>
<li>webpack构建性能优化技巧<br />
<a href="http://www.hangge.com/blog/cache/detail_2105.html">http://www.hangge.com/blog/cache/detail_2105.html</a></li>
</ul>
<p>对于大型 Vue 项目，或者说项目中引入了许多第三方库，那么在执行 npm run build 构建项目的时候会极其的慢，上几十秒甚至几分钟的时间，特别是开发过程中的时段，这是难以接受的等待。</p>
<ul>
<li>模块定位 resolve modules</li>
</ul>
<p>webpack 的 resolve.modules 是用来配置模块库（即 node_modules）所在的位置。当 js 里出现 import &lsquo;vue&rsquo; 这样不是相对、也不是绝对路径的写法时，它便会到 node_modules 目录下去找。在默认配置下，webpack 会采用向上递归搜索的方式去寻找。为了减少搜索范围，可我们以直接写明 node_modules 的全路径。</p>
<p>打开 build/webpack.base.conf.js 文件，添加如下高亮配置：</p>
<pre><code>    resolve: {
        extensions: ['.js', '.vue', '.json'],
        modules: [
          resolve('src'),
          resolve('node_modules')
        ],
        alias: {
          'vue$': 'vue/dist/vue.esm.js',
          '@': resolve('src'),
        }
    },
</code></pre>
<ul>
<li>配置装载机的 include &amp; exclude</li>
</ul>
<p>webpack 的装载机（loaders）里的每个子项都可以有 include 和 exclude 属性。使用 include 更精确地指定要处理的目录，这可以减少不必要的遍历，从而减少性能损失。同时使用 exclude 对于已经明确知道的，不需要处理的目录，予以排除，从而进一步提升性能。</p>
<p>打开 build/webpack.base.conf.js 文件，添加类似如下配置，例如 easytable 没有在项目使用，则可以把它从 include 中去除。</p>
<p>rules: [<br />
    {<br />
      test: /.vue$/,<br />
      loader: &lsquo;vue-loader&rsquo;,<br />
      options: vueLoaderConfig,<br />
      include: [resolve(&lsquo;src&rsquo;), resolve(&lsquo;node_modules/vue-easytable/libs&rsquo;)],<br />
      exclude: /node_modules\/(?!(autotrack|dom-utils))|vendor.dll.js/<br />
    },<br />
    {<br />
      test: /.js$/,<br />
      loader: &lsquo;babel-loader&rsquo;,<br />
      include: [resolve(&lsquo;src&rsquo;)],<br />
      exclude: /node_modules/<br />
    },</p>
<ul>
<li>使用 webpack-parallel-uglify-plugin 插件来压缩代码</li>
</ul>
<p>默认情况下 webpack 使用 UglifyJS 插件进行代码压缩，但由于其采用单线程压缩，速度很慢。可以改用 webpack-parallel-uglify-plugin 插件，它可以并行运行 UglifyJS 插件，从而更加充分、合理的使用 CPU 资源，从而大大减少构建时间。</p>
<p>执行如下命令安装 webpack-parallel-uglify-plugin</p>
<pre><code>npm i webpack-parallel-uglify-plugin
</code></pre>
<p>打开 webpack.prod.conf.js 文件，并作如下修改：</p>
<pre><code>const ParallelUglifyPlugin = require('webpack-parallel-uglify-plugin');
//....
// 删掉webpack提供的UglifyJS插件
//new UglifyJsPlugin({
//  uglifyOptions: {
//    compress: {
//      warnings: false
//    }
//  },
//  sourceMap: config.build.productionSourceMap,
//  parallel: true
//}),
// 增加 webpack-parallel-uglify-plugin来替换
new ParallelUglifyPlugin({
  cacheDir: '.cache/',
  uglifyJS:{
    output: {
      comments: false
    },
    compress: {
      warnings: false
    }
  }
}),
</code></pre>
<ul>
<li>使用 HappyPack 来加速代码构建</li>
</ul>
<p>运行在 Node.js 之上的 Webpack 是单线程模型的，所以 Webpack 需要处理的事情只能一件一件地做，不能多件事一起做。而 HappyPack 的处理思路是：将原有的 webpack 对 loader 的执行过程，从单一进程的形式扩展多进程模式，从而加速代码构建。</p>
<p>执行如下命令安装 happypack：</p>
<pre><code>npm i happypack
</code></pre>
<p>打开 build/webpack.base.conf.js 文件，并作类似如下修改：</p>
<pre><code>const HappyPack = require('happypack');
const os = require('os');
const happyThreadPool = HappyPack.ThreadPool({ size: os.cpus().length });

module.exports = {
    module: {
        rules: [{
            test: /\.js$/,
            //把js文件处理交给id为 happyBabel 的HappyPack 的实例执行
            loader: 'happypack/loader?id=happyBabel',
            include: [path.resolve('src')],
            //排除node_modules 目录下的文件
            exclude: /node_modules/
        }, ]
    },
    plugins: [
        new HappyPack({
            //用id来标识 happypack处理那里类文件
            id: 'happyBabel',
            //如何处理  用法和loader 的配置一样
            loaders: [{
                loader: 'babel-loader?cacheDirectory=true',
            }],
            //共享进程池
            threadPool: happyThreadPool,
            //允许 HappyPack 输出日志
            verbose: true,
        })
    ]
}
</code></pre>
<ul>
<li>启用DllPlugin和DllReferencePlugin预编译库文件<br />
<br />
这是最复杂也是提升效果最明显的一步，原理是将第三方库文件单独编译打包一次，以后的构建都不需要再编译打包第三方库。项目依赖中通常会引用大量的 npm 包，而这些包在正常的开发过程中并不会进行修改，但是在每一次构建过程中却需要反复的将其解析。</li>
</ul>
<p>而这两个插件就是用来规避此类损耗的，DllPlugin 插件用来预先编译一些模块，DllReferencePlugin 插件用来引用这些预先编译好的模块。注意：DllPlugin 必须要在 DllReferencePlugin 执行前先执行一次，dll 这个概念应该也是借鉴了 windows 程序开发中的 dll 文件的设计理念。</p>
<p>首先增加 webpack.dll.config.js 配置文件，并在 entry 中配置需要单独DLL化的模块，以下作为示例，据需求裁剪<br />
<br />
    const path = require(&lsquo;path&rsquo;);<br />
    const webpack = require(&lsquo;webpack&rsquo;);</p>
<pre><code>module.exports = {
    entry: {
        vendor: ['vue/dist/vue.common.js',
            'vue-router',
            'axios',
            'mint-ui',
            'vue-cordova',
            '@fortawesome/fontawesome-svg-core',
            '@fortawesome/free-solid-svg-icons',
            '@fortawesome/free-regular-svg-icons',
            '@fortawesome/free-brands-svg-icons',
            '@fortawesome/vue-fontawesome'
        ]
    },
    output: {
        path: path.join(__dirname, './dist'),
        filename: '[name].dll.js',
        library: '[name]_library' // vendor.dll.js中暴露出的全局变量名
    },
    plugins: [
        new webpack.DllPlugin({
            path: path.join(__dirname, '/dist/', '[name]-manifest.json'),
            name: '[name]_library'
        }),
        new webpack.optimize.UglifyJsPlugin({
            compress: {
                warnings: false
            }
        })
    ]
};
</code></pre>
<p>然后在 webpack.base.conf.js 文件，增加一个插件配置配置，作用是通过 DLLReferencePlugin 来使用 DllPlugin 生成的 DLL Bundle。</p>
<pre><code>// 添加DllReferencePlugin插件
new webpack.DllReferencePlugin({
    context: path.resolve(__dirname, '..'),
    manifest: require('./dist/vendor-manifest.json')
}),
</code></pre>
<p>在 package.json 增加构建命令　　</p>
<pre><code>"dll": "webpack --config webpack.dll.config.js"
</code></pre>
<p>执行构建，这一步会生成 vendor-manifest.json 和 static/js/vendor.dll.js</p>
<pre><code>npm run dll
npm run dev 或 npm run build
</code></pre>
<p>最后在入口页面中 index.html 增加 dll.js 引入，而且必须首先引入，另外将已经独立打包的模块从原有的配置文件 webpack.base.conf.js 中设置为 externals 外部引用</p>
<pre><code>&lt;script src="/static/js/vendor.dll.js"&gt;&lt;/script&gt;

module.exports = {
    externals: {
        'echarts': 'echarts',
        'vue': 'vue',
        'axios': 'axios',
        'iview': 'iview'
    }
}
</code></pre>
<ul>
<li>提取js/css到cdn优化编译大小</li>
</ul>
<p>以一个vue项目为例。项目引用了vue、axios、iview、iview的css：</p>
<pre><code>import Vue from 'vue'
import App from './App.vue'
import router from './router'
import axios from 'axios'
import iView from 'iview'
import echarts from 'echarts'
import 'iview/dist/styles/iview.css'
</code></pre>
<p>在 webpack.base.conf.js 中，增加externals配置：</p>
<p>然后在页面文件 index.html 引入cdn资源文件</p>
<pre><code>&lt;body&gt;
    &lt;div id="app"&gt;&lt;/div&gt;
    &lt;script src="https://cdn.bootcss.com/vue/2.5.2/vue.min.js"&gt;&lt;/script&gt;
    &lt;script src="https://cdn.bootcss.com/axios/0.17.1/axios.min.js"&gt;&lt;/script&gt;
    &lt;script src="https://cdn.bootcss.com/iview/2.6.0/iview.min.js"&gt;&lt;/script&gt;
    &lt;script src="//cdn.staticfile.org/echarts/4.2.0-rc.1/echarts.min.js"&gt;&lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>将大体积文件放置在cdn上，减小了服务器流量压力，加快了不同地区网页加载速度，如百度图表库 echarts 就很大，压缩后的完整包近一个兆的量。另外使用gzip压缩vendor.js可以有效减小文件体积，一般能压缩70%左右。 </p>
<h1 id="render-function-createcomponent"><a name="user-content-render-function-createcomponent" href="#render-function-createcomponent" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>render function &amp; createComponent</h1>
<p><a href="https://vuejs.org/v2/guide/render-function.html">render-function</a><a href="https://cn.vuejs.org/v2/guide/render-function.html">https://cn.vuejs.org/v2/guide/render-function.html</a></p>
<p>Vue 推荐在绝大多数情况下使用 template 来创建你的 HTML。然而在一些场景中，你真的需要 JavaScript 的完全编程的能力，这就是 <a href="https://vuejs.org/v2/api/#render">render</a> 函数，它比 template 更接近编译器。</p>
<p>render: h =&gt; h(App) 这行初始化代码是下面内容的缩写：</p>
<pre><code>render: function (createElement) {
    return createElement(App);
}
</code></pre>
<p>缩写形式有以下3种(ES6 语法)：</p>
<pre><code>render (createElement) {
    return createElement(App);
}

render (h){
    return h(App);
}

render: h =&gt; h(App);
</code></pre>
<p>其中 根据 Vue.js 作者 Even You 的回复，h 的含义如下：</p>
<pre><code>It comes from the term "hyperscript", which is commonly used in many virtual-dom implementations. "Hyperscript" itself stands for "script that generates HTML structures" because HTML is the acronym for "hyper-text markup language".
</code></pre>
<p>它来自单词 hyperscript，这个单词通常用在 virtual-dom 的实现中。Hyperscript 本身是指生成HTML 结构的 script 脚本，因为 HTML 是 hyper-text markup language 的缩写（超文本标记语言）。个人理解：createElement 函数是用来生成 HTML DOM 元素的，也就是上文中的 generate HTML structures，也就是 Hyperscript，这样作者才把 createElement 简写成 h。</p>
<p>下面这个列子展示了 render 函数和 createElemnt 函数结合来动态生成模板，这种使用脚本生成的组件称为函数式组件。</p>
<pre><code>&lt;div id="app"&gt;
    &lt;child v-bind:level="2"&gt;Hello world!&lt;/child&gt;
&lt;/div&gt;

&lt;script type="text/javascript"&gt;

Vue.component('child', {
    render: function (createElement) {
        return createElement(
            'h' + this.level, // tag name 标签名称 h1,h2,h3...
            this.$slots.default // 子组件中的阵列
        )
    },
    props: {
        level: {
            type: Number,
            required: true
        }
    }
})

new Vue({
    el: "#app"
})

&lt;/script&gt;
</code></pre>
<p>关于createElement方法，他是通过render函数的参数传递进来的。它更准确的名字可能是 createNodeDescription，因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，及其子节点。我们把这样的节点描述为“虚拟节点 (Virtual Node)”，也常简写它为“VNode”。VDOM是由 Vue 组件树建立起来的整个 VNode 树的称呼。这个方法有三个参数: <br />
第一个参数（字符串、对象或函数）主要用于提供dom的html内容。比如传入 &ldquo;div&rdquo; 就是创建一个 <div>标签 <br />
第二个参数（类型是对象）主要用于设置这个dom的一些样式、属性、传的组件的参数、绑定事件之类，具体可以参考官方文档 <br />
第三个参数（类型是数组，数组元素类型是VNode）主要用于说是该结点下有其他结点的话，就放在这里。<br />
比如说，有需要分发的标签 <slot>，则通过 this.$slots.default 来获得，或许还有其他组件之类，可能需要被使用的，应该也是放在这里。 </p>
<p>Vue 的模板实际是编译成了 render 函数。这是一个实现细节，通常不需要关心，但如果你想看看模板的功能是怎样被编译的，你会发现会非常有趣。下面是官方文档展示一个使用 Vue.compile 来实时编译模板字符串的简单 demo：</p>
<pre><code>&lt;div&gt;
    &lt;header&gt; &lt;h1&gt;I'm a template!&lt;/h1&gt; &lt;/header&gt;
    &lt;p v-if="message"&gt; {{ message }} &lt;/p&gt;
    &lt;p v-else-if="info"&gt; {{ info }} &lt;/p&gt;
    &lt;p v-else&gt; No message. &lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>Vue 编译后产生的 render，可以猜测这个 &ldquo;<em>c</em>&rdquo; 就是 createElement 的缩写:</p>
<pre><code>function anonymous() {
    with(this){return _c('div',[_m(0),(message)?_c('p',[_v(_s(message))]):_c('p',[_v("No message.")])])}
}

_m(0): function anonymous() {
  with(this){return _c('header',[_c('h1',[_v("I'm a template!")])])}
}
</code></pre>
<h1 id="server-side-render"><a name="user-content-server-side-render" href="#server-side-render" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Server-Side Render</h1>
<p><a href="https://cn.vuejs.org/v2/guide/ssr.html">https://cn.vuejs.org/v2/guide/ssr.html</a></p>
<p>SSR 完全指南 <a href="https://ssr.vuejs.org/zh/">https://ssr.vuejs.org/zh/</a></p>
<p>在 2.3 发布后我们发布了一份完整的构建 Vue 服务端渲染应用的指南。这份指南非常深入，适合已经熟悉 Vue, webpack 和 Node.js 开发的开发者阅读。请移步 ssr.vuejs.org。</p>
<p>Nuxt.js <a href="https://nuxtjs.org/">https://nuxtjs.org/</a></p>
<p>从头搭建一个服务端渲染的应用是相当复杂的。幸运的是，我们有一个优秀的社区项目 Nuxt.js 让这一切变得非常简单。Nuxt 是一个基于 Vue 生态的更高层的框架，为开发服务端渲染的 Vue 应用提供了极其便利的开发体验。更酷的是，你甚至可以用它来做为静态站生成器。</p>
<p>服务端渲染的核心就在于：通过vue-server-renderer插件的renderToString()方法，将Vue实例转换为字符串插入到html文件。</p>
<p>ssr的服务端渲染大致的意思就是vue在客户端将标签渲染成的整个html片段的工作在服务端完成，服务端形成的html片段直接返回给客户端这个过程就叫做服务端渲染。</p>
<ul>
<li>浏览器加载所有资源(html,css,js,img&hellip;)</li>
<li>加载cdn资源</li>
<li>vue请求server获取业务数据</li>
<li>返回渲染后的html片段</li>
<li>css渲染片段成一个网页</li>
</ul>
<p>这里面最耗时的请求服务器并返回渲染HTML片段这两步骤，请求serverapi的过程本身除了服务器的限制，还有用户网络，宽带等等诸多限制，并且当页面逻辑过多，数据过于繁琐的情况下，我们的vue在client端渲染也会成为性能瓶颈。如一些电商公司的首页，商品详情页等等。测试这个过程在优化前大概需要500ms左右，即使经过优化也需要200ms左右，这个时间几乎是难以接受的，并且我们在用户网络不是很好的情况下，如果我们serverfetch的过程需要500ms，再加上其他的各种请求资源，手机性能等等，用户就要看到将近一秒的白屏时间，这个明显是很差的用户体验。</p>
<p>在对你的应用程序使用服务器端渲染(SSR)之前，你应该问的第一个问题是，是否真的需要它。这主要取决于内容到达时间(time-to-content)对应用程序的重要程度。例如，如果你正在构建一个内部仪表盘，初始加载时的额外几百毫秒并不重要，这种情况下去使用服务器端渲染(SSR)将是一个小题大作之举。然而，内容到达时间(time-to-content)要求是绝对关键的指标，在这种情况下，服务器端渲染(SSR)可以帮助你实现最佳的初始加载性能。</p>
<h1 id="iview-cdn"><a name="user-content-iview-cdn" href="#iview-cdn" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>iview CDN引入</h1>
<p>CDN引入方式简单，直接在页面添加CSS和JS标签即可，不像NODE构建环境需要下载大量依赖</p>
<pre><code>&lt;script src="https://cdn.bootcss.com/vue-resource/1.5.1/vue-resource.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="http://vuejs.org/js/vue.min.js"&gt;&lt;/script&gt;
&lt;link rel="stylesheet" type="text/css" href="http://unpkg.com/iview/dist/styles/iview.css"&gt;
&lt;script type="text/javascript" src="http://unpkg.com/iview/dist/iview.min.js"&gt;&lt;/script&gt;

&lt;div id="tabapp"&gt;
    &lt;Tabs value="name1"&gt;
        &lt;Tab-pane label="标签一" name="name1"&gt;标签一的内容&lt;/Tab-pane&gt;
        &lt;Tab-pane label="标签二" name="name2"&gt;标签二的内容&lt;/Tab-pane&gt;
        &lt;Tab-pane label="标签三" name="name3"&gt;标签三的内容&lt;/Tab-pane&gt;
    &lt;/Tabs&gt;
&lt;/div&gt;

&lt;script&gt;
new Vue({
    el: '#tabapp',
})
&lt;/script&gt;
</code></pre>
<p>注意：非 template/render 模式下，组件名字可能需作修改，比如vue文件中的Button，在HTML页面中要使用 i-button。 再如VUE中HTML标签名不分大小，像 TabPane 这种组件名要修改成 Tab-Pane。再有，组件属性中使用了连字符，即减号的在脚本中要转成驼峰写法。</p>
<p>以下组件，在非 template/render 模式下，需要加前缀 i-：</p>
<p>Button: i-button <br />
Col: i-col <br />
Table: i-table <br />
Input: i-input <br />
Form: i-form <br />
Menu: i-menu <br />
Select: i-select <br />
Option: i-option <br />
Progress: i-progress <br />
以下组件，在所有模式下，必须加前缀 i-，除非使用 iview-loader： <br />
Switch: i-switch <br />
Circle: i-circle </p>
<h1 id="iview-node"><a name="user-content-iview-node" href="#iview-node" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>iview NODE构建方式</h1>
<p>NODE方式复杂，设计NODE，需要这方面的项目基础。但这种方式可以使用vue文件编写程序，可以借助webpack对代码打包，具有一定的反抄袭功能。使用 iview-project 脚手架工具帮助建项目，然后执行对应命令安装依赖/进入开发/编译：</p>
<p>iview/iview-project: <a href="https://github.com/iview/iview-project">https://github.com/iview/iview-project</a></p>
<pre><code>npm install
npm run dev
npm run build
</code></pre>
<p>手工建立 iview 项目步骤：</p>
<p>（1）在git bash中安装iview，即：</p>
<pre><code>npm install iview --save
</code></pre>
<p>（2）一般在 webpack 入口页面 main.js 中如下配置并注册iView，即：</p>
<pre><code>import iView from 'iview'
import 'iview/dist/styles/iview.css'

Vue.use(iView)
</code></pre>
<p>（3）为了统一IView标签的书写规范，通过安装iView Loader，即：</p>
<pre><code>npm install iview-loader --save
</code></pre>
<p>然后修改webpack选项，如下：</p>
<pre><code>rules: [
   ...(config.dev.useEslint ? [createLintingRule()] : []),
   {
     test: /\.vue$/,
     use: [
       {
         loader: 'vue-loader',
         options: vueLoaderConfig
       },
       {
         loader: 'iview-loader',
         options: {
             prefix: false
         }
       }
     ]

   },
   {
     test: /\.js$/,
     loader: 'babel-loader',
     include: [resolve('src'), resolve('test'), resolve('node_modules/webpack-dev-server/client')]
}


&lt;template&gt;
    &lt;Tabs type="card" closable @on-tab-remove="handleTabRemove"&gt;
        &lt;TabPane label="标签一" v-if="tab0"&gt;标签一的内容&lt;/TabPane&gt;
        &lt;TabPane label="标签二" v-if="tab1" disabled&gt;标签二的内容&lt;/TabPane&gt;
        &lt;TabPane label="标签三" v-if="tab2"&gt;标签三的内容&lt;/TabPane&gt;
    &lt;/Tabs&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {
        data () {
            return {
                tab0: true,
                tab1: true,
                tab2: true
            }
        },
        methods: {
            handleTabRemove (name) {
                this['tab' + name] = false;
            }
        }
    }
&lt;/script&gt;
</code></pre>
<h1 id="props"><a name="user-content-props" href="#props" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>props 向组件传递参数</h1>
<p>组件属性 prop 定义的方式有两种，一种是简易的形式，使用数组来定义属性名列表即可：</p>
<pre><code>props: ['options', 'moreOptions']
</code></pre>
<p>另一种是完整的定义，包括指定数据类型，指定默认值，<code>validator</code> 自定义验证函数等功能：</p>
<pre><code>props: {
    propA: Number, // 基础类型检测 （`null` 意思是任何类型都可以）
    propB: [String, Number],                    // 多种类型
    propC: { type: String, required: true },    // 必传且是字符串
    propD: { type: Number, default: 100 },      // 数字，有默认值
    propE: { type: Object, default: function () { return { message: 'hello' } } },
    propF: { validator: function (value) { return value &gt; 10 }
}


&lt;div id="components-app"&gt;
    &lt;div :style="{color:color}"&gt;{{state}}&lt;/div&gt;
    &lt;button-counter v-on:reset="doReset" v-for="item in list" v:bind:title="{{item}}"&gt;&lt;/button-counter&gt;
&lt;/div&gt;

&lt;script&gt;
    Vue.component('button-counter', {
        props:['title'],
        data: function () {
            return {
                count: 0
            }
        },
        template: '&lt;button v-on:click="count++; if(count==9) $emit(\'reset\')"&gt;You clicked {{title}} {{ count }} times.&lt;/button&gt;'
    });

    new Vue({ 
        el: '#components-app',
        data:{
            list:['Apple','Pie','Cake'],
            color:'black',
            state:"working"
        },
        methods:{
            doReset:function(res){
                this.color = 'red';
                this.state = "Reset";
            }
        }
    });
&lt;/script&gt;
</code></pre>
<h1 id="refs-template"><a name="user-content-refs-template" href="#refs-template" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>refs 引用及组件成员访问 组件嵌套 template组件模板引用</h1>
<p><a href="https://www.w3cplus.com/vue/seven-ways-to-define-a-component-template-by-vuejs.html">https://www.w3cplus.com/vue/seven-ways-to-define-a-component-template-by-vuejs.html</a></p>
<p>Vue.js 中可以用7种定义组件模板的方法, inline-template:</p>
<pre><code>Vue.component('my-checkbox', {
    data() {
        return {
            checked: false,
            title: 'Check me'
        }
    },
    methods: {
        check() {
            this.checked = !this.checked;
        }
    }
});

&lt;my-checkbox inline-template&gt;
    &lt;div class="checkbox-wrapper" @click="check"&gt;
        &lt;div :class="{ checkbox: true, checked: checked }"&gt;&lt;/div&gt;
        &lt;div class="title"&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/my-checkbox&gt;
</code></pre>
<p>单文件组件<br />
只要你把构建工具设置的很舒服，单文件组件就是模板选项中的王者。它允许你写 HTML 标签定义组件，并且将所有组件定义保留在一个文件中。</p>
<p>尽管它也有一些劣势：需要预编译，某些 IDE 不支持 .vue 文件的语法高亮，不过其地位依然难以被撼动。</p>
<pre><code>&lt;template&gt;
    &lt;div class="checkbox-wrapper" @click="check"&gt;
        &lt;div :class="{ checkbox: true, checked: checked }"&gt;&lt;/div&gt;
        &lt;div class="title"&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {
        data() {
            return {
                checked: false,
                title: 'Check me'
            }
        },
        methods: {
            check() {
                this.checked = !this.checked;
            }
        }
    }
&lt;/script&gt;
</code></pre>
<p>x-template:</p>
<pre><code>&lt;script type="text/x-template" id="checkbox-template"&gt;
    &lt;div class="checkbox-wrapper" @click="check"&gt;
        &lt;div :class="{ checkbox: true, checked: checked }"&gt;&lt;/div&gt;
        &lt;div class="title"&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/script&gt;
</code></pre>
<p>其中模板字符串（Template literals）</p>
<p>通过ES6的模板字符串（反引号 <code></code> ）语法，你在定义模板时可以直接换行，这是通过常规的JavaScript字符串没法做到的。这种写法更容易阅读，并且这种模板字符串语法得到了许多新版本浏览器的支持。当然，为了安全起见，你仍然应该把它转译为ES5的语法形式。</p>
<p>然而，这种方式并不完美，我发现大多数的IDE在语法高亮上做的差强人意，并且在缩进和换行等的格式方面，仍然很痛苦。</p>
<pre><code>&lt;div id="template-app"&gt;
    &lt;i-button @click="doReset"&gt;Reset&lt;/i-button&gt;
    &lt;button-counter ref="demoButton" title="Apple"&gt;&lt;/button-counter&gt;
&lt;/div&gt;

&lt;template id="templateDemo"&gt;
    &lt;i-button v-on:click="count++;"&gt;You clicked {{title}} {{ count }} times.&lt;/i-button&gt;
&lt;/template&gt;

&lt;script&gt;
    Vue.component('button-counter', {
        props:['title'],
        data: function () {
            return {
                count: 0
            }
        },
        methods:{
            reset:function(res){
                this.count = 0;
                console.log(this);
            }
        },
        template: '#templateDemo'
    });

    new Vue({ 
        el: '#template-app',
        methods:{
            doReset:function(){
                console.log(this.$refs);
                this.$refs.demoButton.reset("this call");
            }
        }
    });
&lt;/script&gt;
</code></pre>
<h1 id="vue-10-api-reference"><a name="user-content-vue-10-api-reference" href="#vue-10-api-reference" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Vue 1.0 API Reference 参考文档目录</h1>
<h2 id="global-config"><a name="user-content-global-config" href="#global-config" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Global Config</h2>
<h3 id="debug-v1"><a name="user-content-debug-v1" href="#debug-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>debug</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#debug"><code>debug</code></a></p>
<h3 id="delimiters-v1"><a name="user-content-delimiters-v1" href="#delimiters-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>delimiters</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#delimiters"><code>delimiters</code></a></p>
<h3 id="unsafedelimiters-v1"><a name="user-content-unsafedelimiters-v1" href="#unsafedelimiters-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>unsafeDelimiters</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#unsafeDelimiters"><code>unsafeDelimiters</code></a></p>
<h3 id="silent-v1"><a name="user-content-silent-v1" href="#silent-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>silent</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#silent"><code>silent</code></a></p>
<h3 id="async-v1"><a name="user-content-async-v1" href="#async-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>async</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#async"><code>async</code></a></p>
<h3 id="devtools-v1"><a name="user-content-devtools-v1" href="#devtools-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>devtools</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#devtools"><code>devtools</code></a></p>
<h2 id="global-api"><a name="user-content-global-api" href="#global-api" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Global API</h2>
<h3 id="vueextend-options-v1"><a name="user-content-vueextend-options-v1" href="#vueextend-options-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>Vue.extend( options )</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#Vue-extend"><code>Vue.extend( options )</code></a></p>
<h3 id="vuenexttick-callback-v1"><a name="user-content-vuenexttick-callback-v1" href="#vuenexttick-callback-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>Vue.nextTick( callback )</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#Vue-nextTick"><code>Vue.nextTick( callback )</code></a></p>
<p>Defer the callback to be executed after the next DOM update cycle. Use it immediately after you’ve changed some data to wait for the DOM update.</p>
<pre><code>// modify data
vm.msg = 'Hello'
// DOM not updated yet
Vue.nextTick(function () {
  // DOM updated
})
</code></pre>
<h3 id="vueset-object-key-value-v1"><a name="user-content-vueset-object-key-value-v1" href="#vueset-object-key-value-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>Vue.set( object, key, value )</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#Vue-set"><code>Vue.set( object, key, value )</code></a></p>
<h3 id="vuedelete-object-key-v1"><a name="user-content-vuedelete-object-key-v1" href="#vuedelete-object-key-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>Vue.delete( object, key )</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#Vue-delete"><code>Vue.delete( object, key )</code></a></p>
<h3 id="vuedirective-id-definition-v1"><a name="user-content-vuedirective-id-definition-v1" href="#vuedirective-id-definition-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>Vue.directive( id, [definition] )</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#Vue-directive"><code>Vue.directive( id, [definition] )</code></a></p>
<h3 id="vueelementdirective-id-definition-v1"><a name="user-content-vueelementdirective-id-definition-v1" href="#vueelementdirective-id-definition-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>Vue.elementDirective( id, [definition] )</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#Vue-elementDirective"><code>Vue.elementDirective( id, [definition] )</code></a></p>
<h3 id="vuefilter-id-definition-v1"><a name="user-content-vuefilter-id-definition-v1" href="#vuefilter-id-definition-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>Vue.filter( id, [definition] )</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#Vue-filter"><code>Vue.filter( id, [definition] )</code></a></p>
<h3 id="vuecomponent-id-definition-v1"><a name="user-content-vuecomponent-id-definition-v1" href="#vuecomponent-id-definition-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>Vue.component( id, [definition] )</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#Vue-component"><code>Vue.component( id, [definition] )</code></a></p>
<h3 id="vuetransition-id-hooks-v1"><a name="user-content-vuetransition-id-hooks-v1" href="#vuetransition-id-hooks-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>Vue.transition( id, [hooks] )</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#Vue-transition"><code>Vue.transition( id, [hooks] )</code></a></p>
<h3 id="vuepartial-id-partial-v1"><a name="user-content-vuepartial-id-partial-v1" href="#vuepartial-id-partial-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>Vue.partial( id, [partial] )</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#Vue-partial"><code>Vue.partial( id, [partial] )</code></a></p>
<h3 id="vueuse-plugin-options-v1"><a name="user-content-vueuse-plugin-options-v1" href="#vueuse-plugin-options-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>Vue.use( plugin, [options] )</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#Vue-use"><code>Vue.use( plugin, [options] )</code></a></p>
<h3 id="vuemixin-mixin-v1"><a name="user-content-vuemixin-mixin-v1" href="#vuemixin-mixin-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>Vue.mixin( mixin )</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#Vue-mixin"><code>Vue.mixin( mixin )</code></a></p>
<h2 id="data"><a name="user-content-data" href="#data" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Data</h2>
<h3 id="data-v1"><a name="user-content-data-v1" href="#data-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>data</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#data"><code>data</code></a></p>
<h3 id="props-v1"><a name="user-content-props-v1" href="#props-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>props</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#props"><code>props</code></a></p>
<h3 id="propsdata-v1"><a name="user-content-propsdata-v1" href="#propsdata-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>propsData</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#propsData"><code>propsData</code></a></p>
<h3 id="computed-v1"><a name="user-content-computed-v1" href="#computed-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>computed</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#computed"><code>computed</code></a></p>
<h3 id="methods-v1"><a name="user-content-methods-v1" href="#methods-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>methods</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#methods"><code>methods</code></a></p>
<h3 id="watch-v1"><a name="user-content-watch-v1" href="#watch-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>watch</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#watch"><code>watch</code></a></p>
<h2 id="dom"><a name="user-content-dom" href="#dom" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>DOM</h2>
<h3 id="el-v1"><a name="user-content-el-v1" href="#el-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>el</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#el"><code>el</code></a></p>
<h3 id="template-v1"><a name="user-content-template-v1" href="#template-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>template</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#template"><code>template</code></a></p>
<h3 id="replace-v1"><a name="user-content-replace-v1" href="#replace-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>replace</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#replace"><code>replace</code></a></p>
<h2 id="options-lifecycle-hooks"><a name="user-content-options-lifecycle-hooks" href="#options-lifecycle-hooks" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Options / Lifecycle Hooks</h2>
<p>参考<a href="https://v1.vuejs.org/guide/instance.html#Lifecycle-Diagram">生命周期图</a></p>
<h3 id="init-v1"><a name="user-content-init-v1" href="#init-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>init</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#init"><code>init</code></a></p>
<h3 id="created-v1"><a name="user-content-created-v1" href="#created-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>created</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#created"><code>created</code></a></p>
<h3 id="beforecompile-v1"><a name="user-content-beforecompile-v1" href="#beforecompile-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>beforeCompile</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#beforeCompile"><code>beforeCompile</code></a></p>
<h3 id="compiled-v1"><a name="user-content-compiled-v1" href="#compiled-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>compiled</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#compiled"><code>compiled</code></a></p>
<h3 id="activate-v1"><a name="user-content-activate-v1" href="#activate-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>activate</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#activate"><code>activate</code></a></p>
<h3 id="ready-v1"><a name="user-content-ready-v1" href="#ready-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>ready</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#ready"><code>ready</code></a></p>
<h3 id="attached-v1"><a name="user-content-attached-v1" href="#attached-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>attached</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#attached"><code>attached</code></a></p>
<h3 id="detached-v1"><a name="user-content-detached-v1" href="#detached-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>detached</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#detached"><code>detached</code></a></p>
<h3 id="beforedestroy-v1"><a name="user-content-beforedestroy-v1" href="#beforedestroy-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>beforeDestroy</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#beforeDestroy"><code>beforeDestroy</code></a></p>
<h3 id="destroyed-v1"><a name="user-content-destroyed-v1" href="#destroyed-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>destroyed</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#destroyed"><code>destroyed</code></a></p>
<h2 id="assets"><a name="user-content-assets" href="#assets" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Assets</h2>
<h3 id="directives-v1"><a name="user-content-directives-v1" href="#directives-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>directives</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#directives"><code>directives</code></a></p>
<h3 id="elementdirectives-v1"><a name="user-content-elementdirectives-v1" href="#elementdirectives-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>elementDirectives</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#elementDirectives"><code>elementDirectives</code></a></p>
<h3 id="filters-v1"><a name="user-content-filters-v1" href="#filters-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>filters</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#filters"><code>filters</code></a></p>
<h3 id="components-v1"><a name="user-content-components-v1" href="#components-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>components</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#components"><code>components</code></a></p>
<h3 id="transitions-v1"><a name="user-content-transitions-v1" href="#transitions-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>transitions</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#transitions"><code>transitions</code></a></p>
<h3 id="partials-v1"><a name="user-content-partials-v1" href="#partials-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>partials</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#partials"><code>partials</code></a></p>
<h2 id="misc"><a name="user-content-misc" href="#misc" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Misc</h2>
<h3 id="parent-v1"><a name="user-content-parent-v1" href="#parent-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>parent</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#parent"><code>parent</code></a></p>
<h3 id="events-v1"><a name="user-content-events-v1" href="#events-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>events</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#events"><code>events</code></a></p>
<h3 id="mixins-v1"><a name="user-content-mixins-v1" href="#mixins-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>mixins</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#mixins"><code>mixins</code></a></p>
<h3 id="name-v1"><a name="user-content-name-v1" href="#name-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>name</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#name"><code>name</code></a></p>
<h3 id="extends-v1"><a name="user-content-extends-v1" href="#extends-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>extends</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#extends"><code>extends</code></a></p>
<h2 id="instance-properties"><a name="user-content-instance-properties" href="#instance-properties" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Instance Properties</h2>
<h3 id="vmdata-v1"><a name="user-content-vmdata-v1" href="#vmdata-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>vm.$data</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#vm-data"><code>vm.$data</code></a></p>
<h3 id="vmel-v1"><a name="user-content-vmel-v1" href="#vmel-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>vm.$el</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#vm-el"><code>vm.$el</code></a></p>
<h3 id="vmoptions-v1"><a name="user-content-vmoptions-v1" href="#vmoptions-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>vm.$options</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#vm-options"><code>vm.$options</code></a></p>
<h3 id="vmparent-v1"><a name="user-content-vmparent-v1" href="#vmparent-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>vm.$parent</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#vm-parent"><code>vm.$parent</code></a></p>
<h3 id="vmroot-v1"><a name="user-content-vmroot-v1" href="#vmroot-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>vm.$root</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#vm-root"><code>vm.$root</code></a></p>
<h3 id="vmchildren-v1"><a name="user-content-vmchildren-v1" href="#vmchildren-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>vm.$children</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#vm-children"><code>vm.$children</code></a></p>
<h3 id="vmrefs-v1"><a name="user-content-vmrefs-v1" href="#vmrefs-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>vm.$refs</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#vm-refs"><code>vm.$refs</code></a></p>
<h3 id="vmels-v1"><a name="user-content-vmels-v1" href="#vmels-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>vm.$els</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#vm-els"><code>vm.$els</code></a></p>
<h2 id="data_1"><a name="user-content-data_1" href="#data_1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Data</h2>
<h3 id="vmwatch-exporfn-callback-options-v1"><a name="user-content-vmwatch-exporfn-callback-options-v1" href="#vmwatch-exporfn-callback-options-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>vm.$watch( expOrFn, callback, [options] )</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#vm-watch"><code>vm.$watch( expOrFn, callback, [options] )</code></a></p>
<h3 id="vmget-expression-v1"><a name="user-content-vmget-expression-v1" href="#vmget-expression-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>vm.$get( expression )</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#vm-get"><code>vm.$get( expression )</code></a></p>
<h3 id="vmset-keypath-value-v1"><a name="user-content-vmset-keypath-value-v1" href="#vmset-keypath-value-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>vm.$set( keypath, value )</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#vm-set"><code>vm.$set( keypath, value )</code></a></p>
<h3 id="vmdelete-key-v1"><a name="user-content-vmdelete-key-v1" href="#vmdelete-key-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>vm.$delete( key )</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#vm-delete"><code>vm.$delete( key )</code></a></p>
<h3 id="vmeval-expression-v1"><a name="user-content-vmeval-expression-v1" href="#vmeval-expression-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>vm.$eval( expression )</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#vm-eval"><code>vm.$eval( expression )</code></a></p>
<h3 id="vminterpolate-templatestring-v1"><a name="user-content-vminterpolate-templatestring-v1" href="#vminterpolate-templatestring-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>vm.$interpolate( templateString )</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#vm-interpolate"><code>vm.$interpolate( templateString )</code></a></p>
<h3 id="vmlog-keypath-v1"><a name="user-content-vmlog-keypath-v1" href="#vmlog-keypath-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>vm.$log( [keypath] )</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#vm-log"><code>vm.$log( [keypath] )</code></a></p>
<h2 id="events"><a name="user-content-events" href="#events" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Events</h2>
<h3 id="vmon-event-callback-v1"><a name="user-content-vmon-event-callback-v1" href="#vmon-event-callback-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>vm.$on( event, callback )</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#vm-on"><code>vm.$on( event, callback )</code></a></p>
<h3 id="vmonce-event-callback-v1"><a name="user-content-vmonce-event-callback-v1" href="#vmonce-event-callback-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>vm.$once( event, callback )</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#vm-once"><code>vm.$once( event, callback )</code></a></p>
<h3 id="vmoff-event-callback-v1"><a name="user-content-vmoff-event-callback-v1" href="#vmoff-event-callback-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>vm.$off( [event, callback] )</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#vm-off"><code>vm.$off( [event, callback] )</code></a></p>
<h3 id="vmemit-event-args-v1"><a name="user-content-vmemit-event-args-v1" href="#vmemit-event-args-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>vm.$emit( event, […args] )</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#vm-emit"><code>vm.$emit( event, […args] )</code></a></p>
<h3 id="vmdispatch-event-args-v1"><a name="user-content-vmdispatch-event-args-v1" href="#vmdispatch-event-args-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>vm.$dispatch( event, […args] )</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#vm-dispatch"><code>vm.$dispatch( event, […args] )</code></a></p>
<h3 id="vmbroadcast-event-args-v1"><a name="user-content-vmbroadcast-event-args-v1" href="#vmbroadcast-event-args-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>vm.$broadcast( event, […args] )</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#vm-broadcast"><code>vm.$broadcast( event, […args] )</code></a></p>
<h2 id="dom_1"><a name="user-content-dom_1" href="#dom_1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>DOM</h2>
<h3 id="vmappendto-elementorselector-callback-v1"><a name="user-content-vmappendto-elementorselector-callback-v1" href="#vmappendto-elementorselector-callback-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>vm.$appendTo( elementOrSelector, [callback] )</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#vm-appendTo"><code>vm.$appendTo( elementOrSelector, [callback] )</code></a></p>
<h3 id="vmbefore-elementorselector-callback-v1"><a name="user-content-vmbefore-elementorselector-callback-v1" href="#vmbefore-elementorselector-callback-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>vm.$before( elementOrSelector, [callback] )</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#vm-before"><code>vm.$before( elementOrSelector, [callback] )</code></a></p>
<h3 id="vmafter-elementorselector-callback-v1"><a name="user-content-vmafter-elementorselector-callback-v1" href="#vmafter-elementorselector-callback-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>vm.$after( elementOrSelector, [callback] )</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#vm-after"><code>vm.$after( elementOrSelector, [callback] )</code></a></p>
<h3 id="vmremove-callback-v1"><a name="user-content-vmremove-callback-v1" href="#vmremove-callback-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>vm.$remove( [callback] )</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#vm-remove"><code>vm.$remove( [callback] )</code></a></p>
<h3 id="vmnexttick-callback-v1"><a name="user-content-vmnexttick-callback-v1" href="#vmnexttick-callback-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>vm.$nextTick( callback )</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#vm-nextTick"><code>vm.$nextTick( callback )</code></a></p>
<p>同 <code>Vue.nextTick( callback )</code></p>
<h2 id="lifecycle"><a name="user-content-lifecycle" href="#lifecycle" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Lifecycle</h2>
<h3 id="vmmount-elementorselector-v1"><a name="user-content-vmmount-elementorselector-v1" href="#vmmount-elementorselector-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>vm.$mount( [elementOrSelector] )</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#vm-mount"><code>vm.$mount( [elementOrSelector] )</code></a></p>
<h3 id="vmdestroy-remove-v1"><a name="user-content-vmdestroy-remove-v1" href="#vmdestroy-remove-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>vm.$destroy( [remove] )</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#vm-destroy"><code>vm.$destroy( [remove] )</code></a></p>
<p>Completely destroy a vm. Clean up its connections with other existing vms, unbind all its directives, turn off all event listeners and, if the remove argument is true, remove its associated DOM element or fragment from the DOM.</p>
<p>触发 <code>beforeDestroy</code>、 <code>destroyed</code> 两个生命周期函数。通过不必执行这个方法，只需使用数据响应式 <code>v-if</code>、<code>v-for</code> 就可以做到。</p>
<p>参考<a href="https://v1.vuejs.org/guide/instance.html#Lifecycle-Diagram">生命周期图</a></p>
<h2 id="directives"><a name="user-content-directives" href="#directives" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Directives</h2>
<h3 id="v-text-v1"><a name="user-content-v-text-v1" href="#v-text-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>v-text</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#v-text"><code>v-text</code></a></p>
<h3 id="v-html-v1"><a name="user-content-v-html-v1" href="#v-html-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>v-html</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#v-html"><code>v-html</code></a></p>
<h3 id="v-if-v1"><a name="user-content-v-if-v1" href="#v-if-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>v-if</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#v-if"><code>v-if</code></a></p>
<h3 id="v-show-v1"><a name="user-content-v-show-v1" href="#v-show-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>v-show</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#v-show"><code>v-show</code></a></p>
<h3 id="v-else-v1"><a name="user-content-v-else-v1" href="#v-else-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>v-else</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#v-else"><code>v-else</code></a></p>
<h3 id="v-for-v1"><a name="user-content-v-for-v1" href="#v-for-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>v-for</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#v-for"><code>v-for</code></a></p>
<h3 id="v-on-v1"><a name="user-content-v-on-v1" href="#v-on-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>v-on</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#v-on"><code>v-on</code></a></p>
<h3 id="v-bind-v1"><a name="user-content-v-bind-v1" href="#v-bind-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>v-bind</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#v-bind"><code>v-bind</code></a></p>
<h3 id="v-model-v1"><a name="user-content-v-model-v1" href="#v-model-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>v-model</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#v-model"><code>v-model</code></a></p>
<h3 id="v-ref-v1"><a name="user-content-v-ref-v1" href="#v-ref-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>v-ref</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#v-ref"><code>v-ref</code></a></p>
<h3 id="v-el-v1"><a name="user-content-v-el-v1" href="#v-el-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>v-el</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#v-el"><code>v-el</code></a></p>
<h3 id="v-pre-v1"><a name="user-content-v-pre-v1" href="#v-pre-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>v-pre</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#v-pre"><code>v-pre</code></a></p>
<h3 id="v-cloak-v1"><a name="user-content-v-cloak-v1" href="#v-cloak-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>v-cloak</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#v-cloak"><code>v-cloak</code></a></p>
<h2 id="special-elements"><a name="user-content-special-elements" href="#special-elements" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Special Elements</h2>
<h3 id="component-v1"><a name="user-content-component-v1" href="#component-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>component</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#component"><code>component</code></a></p>
<h3 id="slot-v1"><a name="user-content-slot-v1" href="#slot-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>slot</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#slot"><code>slot</code></a></p>
<h3 id="partial-v1"><a name="user-content-partial-v1" href="#partial-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>partial</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#partial"><code>partial</code></a></p>
<h2 id="filters"><a name="user-content-filters" href="#filters" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Filters</h2>
<h3 id="capitalize-v1"><a name="user-content-capitalize-v1" href="#capitalize-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>capitalize</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#capitalize"><code>capitalize</code></a></p>
<h3 id="uppercase-v1"><a name="user-content-uppercase-v1" href="#uppercase-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>uppercase</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#uppercase"><code>uppercase</code></a></p>
<h3 id="lowercase-v1"><a name="user-content-lowercase-v1" href="#lowercase-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>lowercase</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#lowercase"><code>lowercase</code></a></p>
<h3 id="currency-v1"><a name="user-content-currency-v1" href="#currency-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>currency</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#currency"><code>currency</code></a></p>
<h3 id="pluralize-v1"><a name="user-content-pluralize-v1" href="#pluralize-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>pluralize</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#pluralize"><code>pluralize</code></a></p>
<h3 id="json-v1"><a name="user-content-json-v1" href="#json-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>json</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#json"><code>json</code></a></p>
<h3 id="debounce-v1"><a name="user-content-debounce-v1" href="#debounce-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>debounce</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#debounce"><code>debounce</code></a></p>
<h3 id="limitby-v1"><a name="user-content-limitby-v1" href="#limitby-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>limitBy</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#limitBy"><code>limitBy</code></a></p>
<h3 id="filterby-v1"><a name="user-content-filterby-v1" href="#filterby-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>filterBy</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#filterBy"><code>filterBy</code></a></p>
<h3 id="orderby-v1"><a name="user-content-orderby-v1" href="#orderby-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>orderBy</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#orderBy"><code>orderBy</code></a></p>
<h2 id="methods"><a name="user-content-methods" href="#methods" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Methods</h2>
<h3 id="arraysetindex-value-v1"><a name="user-content-arraysetindex-value-v1" href="#arraysetindex-value-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>array.$set(index, value)</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#array-set-index-value"><code>array.$set(index, value)</code></a></p>
<h3 id="arrayremovereference-v1"><a name="user-content-arrayremovereference-v1" href="#arrayremovereference-v1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>[<code>array.$remove(reference)</code>] v1</h3>
<p><a href="https://v1.vuejs.org/api/#array-remove-reference"><code>array.$remove(reference)</code></a></p>
<h1 id="vue-20-api-reference"><a name="user-content-vue-20-api-reference" href="#vue-20-api-reference" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Vue 2.0 API Reference 参考文档目录</h1>
<h2 id="global-config_1"><a name="user-content-global-config_1" href="#global-config_1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Global Config</h2>
<h3 id="silent-v2"><code>silent</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#silent"><code>silent</code></a></p>
<h3 id="optionmergestrategies-v2"><code>optionMergeStrategies</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#optionMergeStrategies"><code>optionMergeStrategies</code></a></p>
<h3 id="devtools-v2"><code>devtools</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#devtools"><code>devtools</code></a></p>
<h3 id="errorhandler-v2"><code>errorHandler</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#errorHandler"><code>errorHandler</code></a></p>
<h3 id="warnhandler-v2"><code>warnHandler</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#warnHandler"><code>warnHandler</code></a></p>
<h3 id="ignoredelements-v2"><code>ignoredElements</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#ignoredElements"><code>ignoredElements</code></a></p>
<h3 id="keycodes-v2"><code>keyCodes</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#keyCodes"><code>keyCodes</code></a></p>
<h3 id="performance-v2"><code>performance</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#performance"><code>performance</code></a></p>
<h3 id="productiontip-v2"><code>productionTip</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#productionTip"><code>productionTip</code></a></p>
<h2 id="global-api_1"><a name="user-content-global-api_1" href="#global-api_1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Global API</h2>
<h3 id="vueextend-options-v2"><code>Vue.extend( options )</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#Vue-extend"><code>Vue.extend( options )</code></a></p>
<h3 id="vuenexttick-callback-context-v2"><code>Vue.nextTick( [callback, context] )</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#Vue-nextTick"><code>Vue.nextTick( [callback, context] )</code></a></p>
<p>Defer the callback to be executed after the next DOM update cycle. Use it immediately after you’ve changed some data to wait for the DOM update.</p>
<pre><code>// modify data
vm.msg = 'Hello'
// DOM not updated yet
Vue.nextTick(function () {
  // DOM updated
})

// usage as a promise (2.1.0+, see note below)
Vue.nextTick().then(function () {
    // DOM updated
})
</code></pre>
<p>因为 $nextTick() 返回一个 Promise 对象，所以你可以使用新的 ES2016 async/await 语法完成相同的事情：</p>
<pre><code>methods: {
  updateMessage: async function () {
    this.message = '已更新'
    console.log(this.$el.textContent) // =&gt; '未更新'
    await this.$nextTick()
    console.log(this.$el.textContent) // =&gt; '已更新'
  }
}
</code></pre>
<h3 id="vueset-target-propertynameindex-value-v2"><code>Vue.set( target, propertyName/index, value )</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#Vue-set"><code>Vue.set( target, propertyName/index, value )</code></a></p>
<h3 id="vuedelete-target-propertynameindex-v2"><code>Vue.delete( target, propertyName/index )</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#Vue-delete"><code>Vue.delete( target, propertyName/index )</code></a></p>
<h3 id="vuedirective-id-definition-v2"><code>Vue.directive( id, [definition] )</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#Vue-directive"><code>Vue.directive( id, [definition] )</code></a></p>
<h3 id="vuefilter-id-definition-v2"><code>Vue.filter( id, [definition] )</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#Vue-filter"><code>Vue.filter( id, [definition] )</code></a></p>
<h3 id="vuecomponent-id-definition-v2"><code>Vue.component( id, [definition] )</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#Vue-component"><code>Vue.component( id, [definition] )</code></a></p>
<h3 id="vueuse-plugin-v2"><code>Vue.use( plugin )</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#Vue-use"><code>Vue.use( plugin )</code></a></p>
<h3 id="vuemixin-mixin-v2"><code>Vue.mixin( mixin )</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#Vue-mixin"><code>Vue.mixin( mixin )</code></a></p>
<h3 id="vuecompile-template-v2"><code>Vue.compile( template )</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#Vue-compile"><code>Vue.compile( template )</code></a></p>
<h3 id="vueobservable-object-v2"><code>Vue.observable( object )</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#Vue-observable"><code>Vue.observable( object )</code></a></p>
<h3 id="vueversion-v2"><code>Vue.version</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#Vue-version"><code>Vue.version</code></a></p>
<h2 id="options-data"><a name="user-content-options-data" href="#options-data" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Options / Data</h2>
<h3 id="data-v2"><code>data</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#data"><code>data</code></a></p>
<h3 id="props-v2"><code>props</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#props"><code>props</code></a></p>
<h3 id="propsdata-v2"><code>propsData</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#propsData"><code>propsData</code></a></p>
<h3 id="computed-v2"><code>computed</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#computed"><code>computed</code></a></p>
<h3 id="methods-v2"><code>methods</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#methods"><code>methods</code></a></p>
<h3 id="watch-v2"><code>watch</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#watch"><code>watch</code></a></p>
<h2 id="options-dom"><a name="user-content-options-dom" href="#options-dom" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Options / DOM</h2>
<h3 id="el-v2"><code>el</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#el"><code>el</code></a></p>
<h3 id="template-v2"><code>template</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#template"><code>template</code></a></p>
<h3 id="render-v2"><code>render</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#render"><code>render</code></a></p>
<h3 id="rendererror-v2"><code>renderError</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#renderError"><code>renderError</code></a></p>
<h2 id="options-lifecycle-hooks_1"><a name="user-content-options-lifecycle-hooks_1" href="#options-lifecycle-hooks_1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Options / Lifecycle Hooks</h2>
<p>参考[生命周期图]参考[生命周期图]<br />
参考[生命周期]: <a href="https://vuejs.org/v2/guide/instance.html#Lifecycle-Diagram">https://vuejs.org/v2/guide/instance.html#Lifecycle-Diagram</a></p>
<h3 id="beforecreate-v2"><code>beforeCreate</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#beforeCreate"><code>beforeCreate</code></a></p>
<h3 id="created-v2"><code>created</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#created"><code>created</code></a></p>
<h3 id="beforemount-v2"><code>beforeMount</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#beforeMount"><code>beforeMount</code></a></p>
<h3 id="mounted-v2"><code>mounted</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#mounted"><code>mounted</code></a></p>
<h3 id="beforeupdate-v2"><code>beforeUpdate</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#beforeUpdate"><code>beforeUpdate</code></a></p>
<h3 id="updated-v2"><code>updated</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#updated"><code>updated</code></a></p>
<h3 id="activated-v2"><code>activated</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#activated"><code>activated</code></a></p>
<h3 id="deactivated-v2"><code>deactivated</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#deactivated"><code>deactivated</code></a></p>
<h3 id="beforedestroy-v2"><code>beforeDestroy</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#beforeDestroy"><code>beforeDestroy</code></a></p>
<h3 id="destroyed-v2"><code>destroyed</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#destroyed"><code>destroyed</code></a></p>
<h3 id="errorcaptured-v2"><code>errorCaptured</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#errorCaptured"><code>errorCaptured</code></a></p>
<h2 id="options-assets"><a name="user-content-options-assets" href="#options-assets" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Options / Assets</h2>
<h3 id="directives-v2"><code>directives</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#directives"><code>directives</code></a></p>
<h3 id="filters-v2"><code>filters</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#filters"><code>filters</code></a></p>
<h3 id="components-v2"><code>components</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#components"><code>components</code></a></p>
<h2 id="options-composition"><a name="user-content-options-composition" href="#options-composition" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Options / Composition</h2>
<h3 id="parent-v2"><code>parent</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#parent"><code>parent</code></a></p>
<h3 id="mixins-v2"><code>mixins</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#mixins"><code>mixins</code></a></p>
<h3 id="extends-v2"><code>extends</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#extends"><code>extends</code></a></p>
<h3 id="provide-inject-v2"><code>provide / inject</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#provide-inject"><code>provide / inject</code></a></p>
<h2 id="options-misc"><a name="user-content-options-misc" href="#options-misc" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Options / Misc</h2>
<h3 id="name-v2"><code>name</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#name"><code>name</code></a></p>
<h3 id="delimiters-v2"><code>delimiters</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#delimiters"><code>delimiters</code></a></p>
<h3 id="functional-v2"><code>functional</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#functional"><code>functional</code></a></p>
<h3 id="model-v2"><code>model</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#model"><code>model</code></a></p>
<h3 id="inheritattrs-v2"><code>inheritAttrs</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#inheritAttrs"><code>inheritAttrs</code></a></p>
<h3 id="comments-v2"><code>comments</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#comments"><code>comments</code></a></p>
<h2 id="instance-properties_1"><a name="user-content-instance-properties_1" href="#instance-properties_1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Instance Properties</h2>
<h3 id="vmdata-v2"><code>vm.$data</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#vm-data"><code>vm.$data</code></a></p>
<h3 id="vmprops-v2"><code>vm.$props</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#vm-props"><code>vm.$props</code></a></p>
<h3 id="vmel-v2"><code>vm.$el</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#vm-el"><code>vm.$el</code></a></p>
<h3 id="vmoptions-v2"><code>vm.$options</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#vm-options"><code>vm.$options</code></a></p>
<h3 id="vmparent-v2"><code>vm.$parent</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#vm-parent"><code>vm.$parent</code></a></p>
<h3 id="vmroot-v2"><code>vm.$root</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#vm-root"><code>vm.$root</code></a></p>
<h3 id="vmchildren-v2"><code>vm.$children</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#vm-children"><code>vm.$children</code></a></p>
<h3 id="vmslots-v2"><code>vm.$slots</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#vm-slots"><code>vm.$slots</code></a></p>
<h3 id="vmscopedslots-v2"><code>vm.$scopedSlots</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#vm-scopedSlots"><code>vm.$scopedSlots</code></a></p>
<h3 id="vmrefs-v2"><code>vm.$refs</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#vm-refs"><code>vm.$refs</code></a></p>
<h3 id="vmisserver-v2"><code>vm.$isServer</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#vm-isServer"><code>vm.$isServer</code></a></p>
<h3 id="vmattrs-v2"><code>vm.$attrs</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#vm-attrs"><code>vm.$attrs</code></a></p>
<h3 id="vmlisteners-v2"><code>vm.$listeners</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#vm-listeners"><code>vm.$listeners</code></a></p>
<h2 id="instance-methods-data"><a name="user-content-instance-methods-data" href="#instance-methods-data" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Instance Methods / Data</h2>
<h3 id="vmwatch-exporfn-callback-options-v2"><code>vm.$watch( expOrFn, callback, [options] )</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#vm-watch"><code>vm.$watch( expOrFn, callback, [options] )</code></a></p>
<h3 id="vmset-target-propertynameindex-value-v2"><code>vm.$set( target, propertyName/index, value )</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#vm-set"><code>vm.$set( target, propertyName/index, value )</code></a></p>
<h3 id="vmdelete-target-propertynameindex-v2"><code>vm.$delete( target, propertyName/index )</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#vm-delete"><code>vm.$delete( target, propertyName/index )</code></a></p>
<h2 id="instance-methods-events"><a name="user-content-instance-methods-events" href="#instance-methods-events" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Instance Methods / Events</h2>
<h3 id="vmon-event-callback-v2"><code>vm.$on( event, callback )</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#vm-on"><code>vm.$on( event, callback )</code></a></p>
<p>监听当前实例上的自定义事件。事件可以由vm.$emit触发。回调函数会接收所有传入事件触发函数的额外参数。</p>
<h3 id="vmonce-event-callback-v2"><code>vm.$once( event, callback )</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#vm-once"><code>vm.$once( event, callback )</code></a></p>
<p>监听一个自定义事件，但是只触发一次，在第一次触发之后移除监听器。</p>
<h3 id="vmoff-event-callback-v2"><code>vm.$off( [event, callback] )</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#vm-off"><code>vm.$off( [event, callback] )</code></a></p>
<p>移除自定义事件监听器。如果没有提供 <code>event</code> 参数，则移除所有的事件监听器；如果只提供了事件，则移除该事件所有的监听器；如果同时提供了事件与回调，则只移除这个回调的监听器。</p>
<h3 id="vmemit-eventname-args-v2"><code>vm.$emit( eventName, […args] )</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#vm-emit"><code>vm.$emit( eventName, […args] )</code></a></p>
<p>触发当前实例上的事件。附加参数都会传给监听器回调。</p>
<p>示例，只配合一个事件名使用 <code>$emit</code>：</p>
<pre><code>&lt;div id="emit-example-simple"&gt;
  &lt;welcome-button v-on:welcome="sayHi"&gt;&lt;/welcome-button&gt;
&lt;/div&gt;

Vue.component('welcome-button', {
  template: `
    &lt;button v-on:click="$emit('welcome')"&gt;
      Click me to be welcomed
    &lt;/button&gt;
  `
})

new Vue({
  el: '#emit-example-simple',
  methods: {
    sayHi: function () {
      alert('Hi!')
    }
  }
})
</code></pre>
<h2 id="instance-methods-lifecycle"><a name="user-content-instance-methods-lifecycle" href="#instance-methods-lifecycle" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Instance Methods / Lifecycle</h2>
<h3 id="vmmount-elementorselector-v2"><code>vm.$mount( [elementOrSelector] )</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#vm-mount"><code>vm.$mount( [elementOrSelector] )</code></a></p>
<h3 id="vmforceupdate-v2"><code>vm.$forceUpdate()</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#vm-forceUpdate"><code>vm.$forceUpdate()</code></a></p>
<h3 id="vmnexttick-callback-v2"><code>vm.$nextTick( [callback] )</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#vm-nextTick"><code>vm.$nextTick( [callback] )</code></a></p>
<p>同 <code>Vue.nextTick( [callback, context] )</code>，但当前上下文 this 指向当前组件。</p>
<h3 id="vmdestroy-v2"><code>vm.$destroy()</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#vm-destroy"><code>vm.$destroy()</code></a></p>
<p>触发 <code>beforeDestroy</code>、 <code>destroyed</code> 两个生命周期函数。通过不必执行这个方法，只需使用数据响应式 <code>v-if</code>、<code>v-for</code> 就可以做到。</p>
<p>参考[生命周期图]参考[生命周期图]<br />
参考[生命周期]: <a href="https://vuejs.org/v2/guide/instance.html#Lifecycle-Diagram">https://vuejs.org/v2/guide/instance.html#Lifecycle-Diagram</a></p>
<h2 id="directives_1"><a name="user-content-directives_1" href="#directives_1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Directives</h2>
<h3 id="v-text-v2"><code>v-text</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#v-text"><code>v-text</code></a></p>
<h3 id="v-html-v2"><code>v-html</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#v-html"><code>v-html</code></a></p>
<h3 id="v-show-v2"><code>v-show</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#v-show"><code>v-show</code></a></p>
<h3 id="v-if-v2"><code>v-if</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#v-if"><code>v-if</code></a></p>
<h3 id="v-else-v2"><code>v-else</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#v-else"><code>v-else</code></a></p>
<h3 id="v-else-if-v2"><code>v-else-if</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#v-else-if"><code>v-else-if</code></a></p>
<h3 id="v-for-v2"><code>v-for</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#v-for"><code>v-for</code></a></p>
<h3 id="v-on-v2"><code>v-on</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#v-on"><code>v-on</code></a></p>
<h3 id="v-bind-v2"><code>v-bind</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#v-bind"><code>v-bind</code></a></p>
<h3 id="v-model-v2"><code>v-model</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#v-model"><code>v-model</code></a></p>
<h3 id="v-slot-v2"><code>v-slot</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#v-slot"><code>v-slot</code></a></p>
<h3 id="v-pre-v2"><code>v-pre</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#v-pre"><code>v-pre</code></a></p>
<h3 id="v-cloak-v2"><code>v-cloak</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#v-cloak"><code>v-cloak</code></a></p>
<h3 id="v-once-v2"><code>v-once</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#v-once"><code>v-once</code></a></p>
<h2 id="special-attributes"><a name="user-content-special-attributes" href="#special-attributes" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Special Attributes</h2>
<h3 id="key-v2"><code>key</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#key"><code>key</code></a></p>
<p>在 v-for 中指定一个唯一键值，避免 Vue 内部就地重用虚拟节点而造成错误的视图渲染结果</p>
<pre><code>&lt;ul&gt;
  &lt;li v-for="item in items" :key="item.id"&gt;...&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<h3 id="ref-v2"><code>ref</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#ref"><code>ref</code></a></p>
<h3 id="is-v2"><code>is</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#is"><code>is</code></a></p>
<h3 id="slot-v2"><code>slot</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#slot"><code>slot</code></a></p>
<h3 id="slot-scope-v2"><code>slot-scope</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#slot-scope-deprecated"><code>slot-scope</code></a></p>
<h3 id="scope-v-removed"><code>scope</code>] v removed</h3>
<p><a href="https://vuejs.org/v2/api/#scope-removed"><code>scope</code></a></p>
<h2 id="built-in-components"><a name="user-content-built-in-components" href="#built-in-components" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Built-In Components</h2>
<h3 id="component-v2"><code>component</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#component"><code>component</code></a></p>
<h3 id="transition-v2"><code>transition</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#transition"><code>transition</code></a></p>
<h3 id="transition-group-v2"><code>transition-group</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#transition-group"><code>transition-group</code></a></p>
<h3 id="keep-alive-v2"><code>keep-alive</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#keep-alive"><code>keep-alive</code></a></p>
<h3 id="slot-v2_1"><code>slot</code> v2</h3>
<p><a href="https://vuejs.org/v2/api/#slot"><code>slot</code></a></p>
<h2 id="vnode-interface"><a name="user-content-vnode-interface" href="#vnode-interface" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>VNode Interface</h2>
<p>参考 <a href="https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js">VNode class declaration</a>.</p>
<h2 id="server-side-rendering"><a name="user-content-server-side-rendering" href="#server-side-rendering" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Server-Side Rendering</h2>
<p>参考 <a href="https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer">vue-server-renderer package documentation</a>.</p></article></body></html>